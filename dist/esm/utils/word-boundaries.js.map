{"version":3,"file":"word-boundaries.js","sources":["../../../src/utils/word-boundaries.ts"],"sourcesContent":["/**\n * Word Boundary Utilities\n * Check if matches occur at word boundaries for more precise results\n */\n\n/**\n * Check if a match is at a word boundary\n * A word boundary is:\n * - Start of string\n * - After whitespace\n * - After punctuation\n */\nexport function isWordBoundary(text: string, position: number): boolean {\n  // Start of string is always a word boundary\n  if (position === 0) {\n    return true;\n  }\n\n  // Check the character before the position\n  const charBefore = text[position - 1];\n  \n  // Word boundary if previous character is whitespace or punctuation\n  return /[\\s\\-_.,;:!?()[\\]{}'\"\\/\\\\]/.test(charBefore);\n}\n\n/**\n * Check if a match occurs at word boundaries (both start and end)\n */\nexport function matchesAtWordBoundary(\n  text: string,\n  matchStart: number,\n  matchLength: number\n): boolean {\n  const matchEnd = matchStart + matchLength;\n  \n  // Check start boundary\n  const startBoundary = isWordBoundary(text, matchStart);\n  \n  // Check end boundary (either end of string or followed by boundary character)\n  const endBoundary = matchEnd >= text.length || /[\\s\\-_.,;:!?()[\\]{}'\"\\/\\\\]/.test(text[matchEnd]);\n  \n  return startBoundary && endBoundary;\n}\n\n/**\n * Find all word boundary matches of a pattern in text\n */\nexport function findWordBoundaryMatches(\n  text: string,\n  pattern: string,\n  caseSensitive: boolean = false\n): number[] {\n  const positions: number[] = [];\n  const searchText = caseSensitive ? text : text.toLowerCase();\n  const searchPattern = caseSensitive ? pattern : pattern.toLowerCase();\n  \n  let index = 0;\n  while (index < searchText.length) {\n    const found = searchText.indexOf(searchPattern, index);\n    \n    if (found === -1) {\n      break;\n    }\n    \n    // Check if this match is at a word boundary\n    if (matchesAtWordBoundary(text, found, searchPattern.length)) {\n      positions.push(found);\n    }\n    \n    index = found + 1;\n  }\n  \n  return positions;\n}\n\n/**\n * Check if query matches word with word boundaries\n */\nexport function matchesWord(word: string, query: string, wordBoundaries: boolean): boolean {\n  if (!wordBoundaries) {\n    // No word boundary checking - substring match is fine\n    return word.toLowerCase().includes(query.toLowerCase());\n  }\n  \n  // With word boundaries - must match at word boundary\n  const positions = findWordBoundaryMatches(word, query, false);\n  return positions.length > 0;\n}\n\n/**\n * Check if a word starts with query (prefix match with word boundaries)\n */\nexport function startsWithWord(word: string, query: string, wordBoundaries: boolean): boolean {\n  const wordLower = word.toLowerCase();\n  const queryLower = query.toLowerCase();\n  \n  if (!wordBoundaries) {\n    return wordLower.startsWith(queryLower);\n  }\n  \n  // With word boundaries - check if it starts at position 0 (which is always a boundary)\n  return wordLower.startsWith(queryLower);\n}\n\n/**\n * Parse wildcard pattern (supports * for any characters)\n */\nexport function parseWildcard(pattern: string): RegExp {\n  // Escape special regex characters except *\n  const escaped = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  \n  // Replace * with .*\n  const regexPattern = escaped.replace(/\\*/g, '.*');\n  \n  // Create regex with word boundaries if no wildcards\n  return new RegExp(`^${regexPattern}$`, 'i');\n}\n\n/**\n * Check if word matches wildcard pattern\n */\nexport function matchesWildcard(word: string, pattern: string): boolean {\n  const regex = parseWildcard(pattern);\n  return regex.test(word);\n}\n"],"names":[],"mappings":"AAYO,SAAS,eAAe,MAAc,UAA2B;AAEtE,MAAI,aAAa,GAAG;AAClB,WAAO;AAAA,EACT;AAGA,QAAM,aAAa,KAAK,WAAW,CAAC;AAGpC,SAAO,6BAA6B,KAAK,UAAU;AACrD;AAKO,SAAS,sBACd,MACA,YACA,aACS;AACT,QAAM,WAAW,aAAa;AAG9B,QAAM,gBAAgB,eAAe,MAAM,UAAU;AAGrD,QAAM,cAAc,YAAY,KAAK,UAAU,6BAA6B,KAAK,KAAK,QAAQ,CAAC;AAE/F,SAAO,iBAAiB;AAC1B;AAKO,SAAS,wBACd,MACA,SACA,gBAAyB,OACf;AACV,QAAM,YAAsB,CAAA;AAC5B,QAAM,aAAa,gBAAgB,OAAO,KAAK,YAAA;AAC/C,QAAM,gBAAgB,gBAAgB,UAAU,QAAQ,YAAA;AAExD,MAAI,QAAQ;AACZ,SAAO,QAAQ,WAAW,QAAQ;AAChC,UAAM,QAAQ,WAAW,QAAQ,eAAe,KAAK;AAErD,QAAI,UAAU,IAAI;AAChB;AAAA,IACF;AAGA,QAAI,sBAAsB,MAAM,OAAO,cAAc,MAAM,GAAG;AAC5D,gBAAU,KAAK,KAAK;AAAA,IACtB;AAEA,YAAQ,QAAQ;AAAA,EAClB;AAEA,SAAO;AACT;AAKO,SAAS,YAAY,MAAc,OAAe,gBAAkC;AACzF,MAAI,CAAC,gBAAgB;AAEnB,WAAO,KAAK,YAAA,EAAc,SAAS,MAAM,aAAa;AAAA,EACxD;AAGA,QAAM,YAAY,wBAAwB,MAAM,OAAO,KAAK;AAC5D,SAAO,UAAU,SAAS;AAC5B;AAoBO,SAAS,cAAc,SAAyB;AAErD,QAAM,UAAU,QAAQ,QAAQ,sBAAsB,MAAM;AAG5D,QAAM,eAAe,QAAQ,QAAQ,OAAO,IAAI;AAGhD,SAAO,IAAI,OAAO,IAAI,YAAY,KAAK,GAAG;AAC5C;AAKO,SAAS,gBAAgB,MAAc,SAA0B;AACtE,QAAM,QAAQ,cAAc,OAAO;AACnC,SAAO,MAAM,KAAK,IAAI;AACxB;"}