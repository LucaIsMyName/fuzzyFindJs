{"version":3,"file":"index.js","sources":["../../../src/core/index.ts"],"sourcesContent":["import type {\n  //\n  FuzzyIndex,\n  FuzzyConfig,\n  SuggestionResult,\n  SearchMatch,\n  BuildIndexOptions,\n  SearchOptions,\n  LanguageProcessor,\n} from \"./types.js\";\nimport {\n  //\n  mergeConfig,\n  validateConfig,\n} from \"./config.js\";\nimport {\n  //\n  LanguageRegistry,\n} from \"../languages/index.js\";\nimport {\n  //\n  calculateLevenshteinDistance,\n  calculateDamerauLevenshteinDistance,\n  calculateNgramSimilarity,\n} from \"../algorithms/levenshtein.js\";\nimport {\n  //\n  buildInvertedIndex,\n  searchInvertedIndex,\n  calculateBM25Scores,\n} from \"./inverted-index.js\";\nimport {\n  //\n  calculateHighlights,\n} from \"./highlighting.js\";\nimport {\n  //\n  SearchCache,\n} from \"./cache.js\";\nimport { removeAccents } from \"../utils/accent-normalization.js\";\nimport { extractFieldValues, normalizeFieldWeights } from \"./field-weighting.js\";\nimport { filterStopWords } from \"../utils/stop-words.js\";\nimport { matchesWord, matchesWildcard } from \"../utils/word-boundaries.js\";\nimport { parseQuery } from \"../utils/phrase-parser.js\";\nimport { matchPhrase } from \"./phrase-matching.js\";\nimport { detectLanguages, sampleTextForDetection } from \"../utils/language-detection.js\";\nimport { isFQLQuery, executeFQLQuery } from \"../fql/index.js\";\nimport { applyFilters } from \"./filters.js\";\nimport { applySorting } from \"./sorting.js\";\n\n/**\n * Builds a fuzzy search index from an array of words or objects.\n * \n * This is the primary function for creating a searchable index. It processes each word/object\n * through language-specific processors, builds various indices (phonetic, n-gram, synonym),\n * and automatically enables optimizations like inverted index for large datasets (10k+ items).\n * \n * @param words - Array of strings to index, or objects with fields to search across\n * @param options - Configuration options for index building\n * @param options.config - Fuzzy search configuration (languages, features, thresholds)\n * @param options.languageProcessors - Custom language processors (overrides default)\n * @param options.onProgress - Callback for tracking indexing progress (processed, total)\n * @param options.useInvertedIndex - Force inverted index usage (auto-enabled for 10k+ words)\n * @param options.fields - Field names for multi-field search (required when indexing objects)\n * @param options.fieldWeights - Weight multipliers for field scoring (e.g., {title: 2.0, description: 1.0})\n * \n * @returns A searchable fuzzy index containing all processed data and metadata\n * \n * @throws {Error} If no language processors found for specified languages\n * @throws {Error} If objects are provided without specifying fields via options.fields\n * \n * @example\n * ```typescript\n * // Simple string array\n * const index = buildFuzzyIndex(['apple', 'banana', 'cherry'], {\n *   config: { languages: ['english'], performance: 'fast' }\n * });\n * \n * // Multi-field objects\n * const products = [\n *   { name: 'iPhone', description: 'Smartphone', price: 999 },\n *   { name: 'MacBook', description: 'Laptop', price: 1999 }\n * ];\n * const index = buildFuzzyIndex(products, {\n *   fields: ['name', 'description'],\n *   fieldWeights: { name: 2.0, description: 1.0 }\n * });\n * \n * // With progress tracking\n * const index = buildFuzzyIndex(largeDataset, {\n *   onProgress: (processed, total) => {\n *     console.log(`Indexing: ${(processed/total*100).toFixed(1)}%`);\n *   }\n * });\n * ```\n * \n * @see {@link getSuggestions} for searching the index\n * @see {@link BuildIndexOptions} for all configuration options\n * @see {@link FuzzyConfig} for fuzzy search settings\n */\nexport function buildFuzzyIndex(words: (string | any)[] = [], options: BuildIndexOptions = {}): FuzzyIndex {\n  // AUTO-DETECTION: Detect languages if not explicitly specified\n  const userSpecifiedLanguages = options.config?.languages;\n  const shouldAutoDetect = !userSpecifiedLanguages || userSpecifiedLanguages.includes('auto');\n  \n  const config = mergeConfig(options.config);\n  \n  if (shouldAutoDetect) {\n    const sampleText = sampleTextForDetection(words, 100);\n    const detectedLanguages = detectLanguages(sampleText);\n    config.languages = detectedLanguages;\n  }\n  \n  validateConfig(config);\n\n  // Convert features array to Set for O(1) lookup performance\n  const featureSet = new Set(config.features);\n\n  const languageProcessors = options.languageProcessors || LanguageRegistry.getProcessors(config.languages);\n\n  if (languageProcessors.length === 0) {\n    throw new Error(`No language processors found for: ${config.languages.join(\", \")}`);\n  }\n\n  // Check if we're doing multi-field search\n  const hasFields = options.fields && options.fields.length > 0;\n  const isObjectArray = words.length > 0 && typeof words[0] === \"object\" && words[0] !== null;\n\n  // Validate: if objects are provided, fields must be specified\n  if (isObjectArray && !hasFields) {\n    throw new Error(\"When indexing objects, you must specify which fields to index via options.fields\");\n  }\n\n  const index: FuzzyIndex = {\n    base: [],\n    variantToBase: new Map(),\n    phoneticToBase: new Map(),\n    ngramIndex: new Map(),\n    synonymMap: new Map(),\n    languageProcessors: new Map(),\n    config,\n  };\n\n  // Store field configuration if provided\n  if (hasFields) {\n    index.fields = options.fields;\n    index.fieldWeights = normalizeFieldWeights(options.fields!, options.fieldWeights);\n    index.fieldData = new Map();\n  }\n\n  // Store language processors\n  languageProcessors.forEach((processor) => {\n    index.languageProcessors.set(processor.language, processor);\n  });\n\n  // OPTIMIZATION 2: Decide early whether to use inverted index to avoid building redundant structures\n  // Use inverted index for large datasets (10k+) or when explicitly requested\n  const shouldUseInvertedIndex = options.useInvertedIndex || config.useInvertedIndex || config.useBM25 || config.useBloomFilter || words.length >= 10000;\n\n  const processedWords = new Set<string>();\n  let processed = 0;\n\n  // OPTIMIZATION 2: Only build hash maps if NOT using inverted index\n  // This avoids storing the same data twice in different structures\n  if (!shouldUseInvertedIndex) {\n    for (const item of words) {\n      if (!item) continue;\n\n      // Handle multi-field objects\n      if (hasFields && isObjectArray) {\n        const fieldValues = extractFieldValues(item, options.fields);\n        if (!fieldValues) continue;\n\n        // Generate a unique ID for this object (use first field value as base)\n        const baseId = Object.values(fieldValues)[0] || `item_${processed}`;\n\n        // Store field data\n        index.fieldData!.set(baseId, fieldValues);\n\n        // Index each field separately\n        for (const [fieldName, fieldValue] of Object.entries(fieldValues)) {\n          if (!fieldValue || fieldValue.trim().length < config.minQueryLength) continue;\n\n          const trimmedValue = fieldValue.trim();\n\n          // Add to base if not already there\n          if (!processedWords.has(baseId.toLowerCase())) {\n            processedWords.add(baseId.toLowerCase());\n            index.base.push(baseId);\n          }\n\n          // Process this field value with each language processor\n          for (const processor of languageProcessors) {\n            processWordWithProcessorAndField(trimmedValue, baseId, fieldName, processor, index, config, featureSet);\n          }\n        }\n      } else {\n        // Handle simple string array (backwards compatible)\n        const word = typeof item === \"string\" ? item : String(item);\n        if (word.trim().length < config.minQueryLength) continue;\n\n        const trimmedWord = word.trim();\n        if (processedWords.has(trimmedWord.toLowerCase())) continue;\n\n        processedWords.add(trimmedWord.toLowerCase());\n        index.base.push(trimmedWord);\n\n        // Process with each language processor\n        for (const processor of languageProcessors) {\n          processWordWithProcessor(trimmedWord, processor, index, config, featureSet);\n        }\n      }\n\n      processed++;\n      if (options.onProgress) {\n        options.onProgress(processed, words.length);\n      }\n    }\n  }\n\n  // INVERTED INDEX: Build for large datasets (contains all the data we need)\n  if (shouldUseInvertedIndex) {\n    const { invertedIndex, documents } = buildInvertedIndex(words, languageProcessors, config, featureSet);\n    index.invertedIndex = invertedIndex;\n    index.documents = documents;\n    \n    // Populate base array from documents for compatibility\n    index.base = documents.map(doc => doc.word);\n  }\n\n  // CACHE: Initialize search result cache if enabled (default: true)\n  const enableCache = config.enableCache !== false; // Default to true\n  if (enableCache) {\n    const cacheSize = config.cacheSize || 100;\n    index._cache = new SearchCache(cacheSize);\n  }\n\n  return index;\n}\n\n/**\n * Process a word with a specific language processor\n */\nfunction processWordWithProcessor(word: string, processor: LanguageProcessor, index: FuzzyIndex, config: FuzzyConfig, featureSet: Set<string>): void {\n  const normalized = processor.normalize(word);\n\n  // OPTIMIZATION: Store only lowercase normalized form to eliminate duplicates\n  // All case variations (apple, Apple, APPLE) map to same lowercase key\n  addToVariantMap(index.variantToBase, normalized.toLowerCase(), word);\n\n  // Add accent-insensitive variants (also normalized to lowercase)\n  const accentFreeWord = removeAccents(word);\n  if (accentFreeWord !== word) {\n    const normalizedAccentFree = processor.normalize(accentFreeWord).toLowerCase();\n    // Only add if different from the already-stored normalized form\n    if (normalizedAccentFree !== normalized.toLowerCase()) {\n      addToVariantMap(index.variantToBase, normalizedAccentFree, word);\n    }\n  }\n\n  // Generate and index variants (normalized to lowercase)\n  if (featureSet.has(\"partial-words\")) {\n    const variants = processor.getWordVariants(word, config.performance);\n    variants.forEach((variant) => {\n      addToVariantMap(index.variantToBase, variant.toLowerCase(), word);\n    });\n  }\n\n  // Generate phonetic codes\n  if (featureSet.has(\"phonetic\") && processor.supportedFeatures.includes(\"phonetic\")) {\n    const phoneticCode = processor.getPhoneticCode(word);\n    if (phoneticCode) {\n      addToVariantMap(index.phoneticToBase, phoneticCode, word);\n    }\n  }\n\n  // Generate n-grams for partial matching (normalized to lowercase)\n  // OPTIMIZATION 3: Limit n-gram generation in fast mode to reduce index size\n  const shouldLimitNgrams = config.performance === 'fast' && normalized.length > 15;\n  const ngramSource = shouldLimitNgrams ? normalized.substring(0, 15) : normalized;\n  const ngrams = generateNgrams(ngramSource.toLowerCase(), config.ngramSize);\n  ngrams.forEach((ngram: string) => {\n    addToVariantMap(index.ngramIndex, ngram, word);\n  });\n\n  // Handle compound words (normalized to lowercase)\n  if (featureSet.has(\"compound\") && processor.supportedFeatures.includes(\"compound\")) {\n    const compoundParts = processor.splitCompoundWords(word);\n    compoundParts.forEach((part) => {\n      if (part !== word) {\n        addToVariantMap(index.variantToBase, processor.normalize(part).toLowerCase(), word);\n      }\n    });\n  }\n\n  // Add synonyms (normalized to lowercase)\n  if (featureSet.has(\"synonyms\")) {\n    const synonyms = processor.getSynonyms(normalized);\n    synonyms.forEach((synonym) => {\n      addToVariantMap(index.synonymMap, synonym.toLowerCase(), word);\n    });\n\n    // Add custom synonyms\n    if (config.customSynonyms) {\n      const customSynonyms = config.customSynonyms[normalized.toLowerCase()];\n      if (customSynonyms) {\n        customSynonyms.forEach((synonym) => {\n          addToVariantMap(index.synonymMap, synonym.toLowerCase(), word);\n        });\n      }\n    }\n  }\n}\n\n/**\n * Process a word with field information for multi-field search\n */\nfunction processWordWithProcessorAndField(fieldValue: string, baseId: string, fieldName: string, processor: LanguageProcessor, index: FuzzyIndex, config: FuzzyConfig, featureSet: Set<string>): void {\n  const normalized = processor.normalize(fieldValue);\n\n  // OPTIMIZATION: Store only lowercase normalized form to eliminate duplicates\n  addToVariantMapWithField(index.variantToBase, normalized.toLowerCase(), baseId, fieldName);\n\n  // Add accent-insensitive variants (normalized to lowercase)\n  const accentFreeWord = removeAccents(fieldValue);\n  if (accentFreeWord !== fieldValue) {\n    const normalizedAccentFree = processor.normalize(accentFreeWord).toLowerCase();\n    if (normalizedAccentFree !== normalized.toLowerCase()) {\n      addToVariantMapWithField(index.variantToBase, normalizedAccentFree, baseId, fieldName);\n    }\n  }\n\n  // Generate and index variants (normalized to lowercase)\n  if (featureSet.has(\"partial-words\")) {\n    const variants = processor.getWordVariants(fieldValue, config.performance);\n    variants.forEach((variant) => {\n      addToVariantMapWithField(index.variantToBase, variant.toLowerCase(), baseId, fieldName);\n    });\n  }\n\n  // Generate phonetic codes\n  if (featureSet.has(\"phonetic\") && processor.supportedFeatures.includes(\"phonetic\")) {\n    const phoneticCode = processor.getPhoneticCode(fieldValue);\n    if (phoneticCode) {\n      addToVariantMapWithField(index.phoneticToBase, phoneticCode, baseId, fieldName);\n    }\n  }\n\n  // Generate n-grams for partial matching (normalized to lowercase)\n  // OPTIMIZATION 3: Limit n-gram generation in fast mode to reduce index size\n  const shouldLimitNgrams = config.performance === 'fast' && normalized.length > 15;\n  const ngramSource = shouldLimitNgrams ? normalized.substring(0, 15) : normalized;\n  const ngrams = generateNgrams(ngramSource.toLowerCase(), config.ngramSize);\n  ngrams.forEach((ngram: string) => {\n    addToVariantMapWithField(index.ngramIndex, ngram, baseId, fieldName);\n  });\n\n  // Handle compound words (normalized to lowercase)\n  if (featureSet.has(\"compound\") && processor.supportedFeatures.includes(\"compound\")) {\n    const parts = processor.splitCompoundWords(fieldValue);\n    parts.forEach((part) => {\n      if (part.length >= config.minQueryLength) {\n        addToVariantMapWithField(index.variantToBase, processor.normalize(part).toLowerCase(), baseId, fieldName);\n      }\n    });\n  }\n\n  // Add synonyms (normalized to lowercase)\n  if (featureSet.has(\"synonyms\")) {\n    const synonyms = processor.getSynonyms(normalized);\n    synonyms.forEach((synonym) => {\n      addToVariantMapWithField(index.synonymMap, synonym.toLowerCase(), baseId, fieldName);\n    });\n\n    // Add custom synonyms\n    if (config.customSynonyms) {\n      const customSynonyms = config.customSynonyms[normalized.toLowerCase()];\n      if (customSynonyms) {\n        customSynonyms.forEach((synonym) => {\n          addToVariantMapWithField(index.synonymMap, synonym.toLowerCase(), baseId, fieldName);\n        });\n      }\n    }\n  }\n}\n\n/**\n * Helper function to add mappings to variant maps with field information\n */\nfunction addToVariantMapWithField(map: Map<string, Set<string>>, key: string, value: string, _fieldName: string): void {\n  // For now, we'll use a simple approach: store the value with field metadata\n  // The field information will be tracked separately in the index\n  // _fieldName is prefixed with _ to indicate it's reserved for future use\n  if (!map.has(key)) {\n    map.set(key, new Set());\n  }\n  map.get(key)!.add(value);\n}\n\n/**\n * Helper function to add mappings to variant maps\n */\nfunction addToVariantMap(map: Map<string, Set<string>>, key: string, value: string): void {\n  if (!map.has(key)) {\n    map.set(key, new Set());\n  }\n  map.get(key)!.add(value);\n}\n\n/**\n * Searches multiple queries at once with automatic deduplication.\n * \n * This function efficiently processes multiple search queries by deduplicating identical\n * queries and leveraging the search cache. Perfect for batch processing or multi-field forms.\n * \n * @param index - The fuzzy search index to search against\n * @param queries - Array of search query strings\n * @param maxResults - Maximum results per query (optional, defaults to index config)\n * @param options - Search options to apply to all queries\n * \n * @returns Object mapping each unique query to its search results\n * \n * @example\n * ```typescript\n * const results = batchSearch(index, ['apple', 'banana', 'apple', 'cherry']);\n * // Returns: { apple: [...], banana: [...], cherry: [...] }\n * // Note: 'apple' only searched once despite appearing twice\n * \n * // With options\n * const results = batchSearch(index, ['app', 'ban'], 5, {\n *   includeHighlights: true,\n *   fuzzyThreshold: 0.8\n * });\n * ```\n * \n * @see {@link getSuggestions} for single query search\n */\nexport function batchSearch(index: FuzzyIndex, queries: string[], maxResults?: number, options: SearchOptions = {}): Record<string, SuggestionResult[]> {\n  const results: Record<string, SuggestionResult[]> = {};\n  const uniqueQueries = [...new Set(queries)]; // Deduplicate\n\n  for (const query of uniqueQueries) {\n    results[query] = getSuggestions(index, query, maxResults, options);\n  }\n\n  return results;\n}\n\n/**\n * Searches the index for fuzzy matches to the query string.\n * \n * This is the primary search function. It automatically selects the optimal search strategy\n * (inverted index for large datasets, hash-based for smaller ones), handles phrase search,\n * FQL queries, stop word filtering, and caching for performance.\n * \n * @param index - The fuzzy search index to search against\n * @param query - The search query string (supports phrases in quotes, FQL with fql() wrapper)\n * @param maxResults - Maximum number of results to return (optional, defaults to index config)\n * @param options - Search options to customize behavior\n * @param options.fuzzyThreshold - Override fuzzy matching threshold (0-1, higher = stricter)\n * @param options.languages - Filter to specific languages\n * @param options.matchTypes - Filter to specific match types (exact, fuzzy, phonetic, etc.)\n * @param options.debug - Include debug information in results\n * @param options.includeHighlights - Include match position highlights for UI rendering\n * @param options.enableFQL - Enable Fuzzy Query Language support (AND, OR, NOT operators)\n * \n * @returns Array of suggestion results sorted by relevance score (highest first)\n * \n * @example\n * ```typescript\n * // Basic search\n * const results = getSuggestions(index, 'hospitl', 5);\n * // Returns: [{ display: 'Hospital', score: 0.92, ... }]\n * \n * // With highlights for UI\n * const results = getSuggestions(index, 'app', 10, {\n *   includeHighlights: true\n * });\n * // Results include highlight positions for rendering\n * \n * // Phrase search\n * const results = getSuggestions(index, '\"new york\"');\n * // Finds multi-word phrases\n * \n * // FQL query\n * const results = getSuggestions(index, 'fql(doctor AND berlin)', 10, {\n *   enableFQL: true\n * });\n * \n * // With debug info\n * const results = getSuggestions(index, 'query', 5, { debug: true });\n * // Results include timing and match details\n * ```\n * \n * @see {@link buildFuzzyIndex} for creating the index\n * @see {@link batchSearch} for searching multiple queries\n */\nexport function getSuggestions(index: FuzzyIndex, query: string, maxResults?: number, options: SearchOptions = {}): SuggestionResult[] {\n  const config = index.config;\n  const limit = maxResults || options.maxResults || config.maxResults;\n  const threshold = options.fuzzyThreshold || config.fuzzyThreshold;\n\n  if (!query || query.trim().length < config.minQueryLength) {\n    return [];\n  }\n\n  // FQL: Check if FQL is enabled and query is FQL\n  if (options.enableFQL && isFQLQuery(query)) {\n    return executeFQLQuery(index, query, limit, options);\n  }\n\n  // PHRASE SEARCH: Check if query contains phrases\n  const parsedQuery = parseQuery(query);\n  \n  // If query has phrases, use phrase search\n  if (parsedQuery.hasPhrases) {\n    return searchWithPhrases(index, parsedQuery, limit, threshold, options);\n  }\n\n  // STOP WORDS: Filter stop words from query if enabled\n  let processedQuery = query;\n  if (config.enableStopWords && config.stopWords && config.stopWords.length > 0) {\n    processedQuery = filterStopWords(query, config.stopWords);\n  }\n\n  // CACHE: Check cache first (use processed query for cache key)\n  if (index._cache) {\n    const cached = index._cache.get(processedQuery, limit, options);\n    if (cached) {\n      return cached; // Cache hit - return immediately!\n    }\n  }\n\n  // Get active language processors\n  const activeLanguages = options.languages || config.languages;\n  const processors = activeLanguages.map((lang) => index.languageProcessors.get(lang)).filter((p): p is LanguageProcessor => p !== undefined);\n\n  if (processors.length === 0) {\n    return [];\n  }\n\n  // AUTO-DETECTION: Use inverted index if available\n  if (index.invertedIndex && index.documents) {\n    const results = getSuggestionsInverted(index, processedQuery, limit, threshold, processors, options);\n    // Cache the results\n    if (index._cache) {\n      index._cache.set(processedQuery, results, limit, options);\n    }\n    return results;\n  }\n\n  // CLASSIC: Use hash-based approach (existing implementation)\n  const matches = new Map<string, SearchMatch>();\n\n  // Process query with each language processor\n  for (const processor of processors) {\n    const normalizedQuery = processor.normalize(processedQuery.trim());\n\n    // Find matches using different strategies\n    findExactMatches(normalizedQuery, index, matches, processor.language);\n    findPrefixMatches(normalizedQuery, index, matches, processor.language);\n    findPhoneticMatches(normalizedQuery, processor, index, matches);\n    findSynonymMatches(normalizedQuery, index, matches);\n    findNgramMatches(normalizedQuery, index, matches, processor.language, config.ngramSize);\n\n    if (config.features.includes(\"missing-letters\") || config.features.includes(\"extra-letters\") || config.features.includes(\"transpositions\")) {\n      findFuzzyMatches(normalizedQuery, index, matches, processor, config);\n    }\n  }\n\n  // Convert matches to results and rank them\n  let results = Array.from(matches.values())\n    .map((match) => createSuggestionResult(match, processedQuery, threshold, index, options))\n    .filter((result): result is SuggestionResult => result !== null);\n\n  // Apply filters if provided\n  if (options.filters) {\n    results = applyFilters(results, options.filters);\n  }\n\n  // Apply custom sorting if provided\n  if (options.sort) {\n    results = applySorting(results, options.sort);\n  } else {\n    // Default: sort by relevance (score DESC, then edit distance ASC, then length ASC)\n    results = results.sort((a, b) => {\n      // Primary: score (higher is better)\n      if (Math.abs(a.score - b.score) > 0.001) {\n        return b.score - a.score;\n      }\n      // Secondary: edit distance (lower is better)\n      const editDistA = a._editDistance ?? Infinity;\n      const editDistB = b._editDistance ?? Infinity;\n      if (editDistA !== editDistB) {\n        return editDistA - editDistB;\n      }\n      // Tertiary: length (shorter is better)\n      return a.display.length - b.display.length;\n    });\n  }\n\n  // Limit results\n  results = results.slice(0, limit);\n\n  // Cache the results\n  if (index._cache) {\n    index._cache.set(processedQuery, results, limit, options);\n  }\n\n  return results;\n}\n\n/**\n * Find exact matches\n */\nfunction findExactMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>, language: string): void {\n  const wordBoundaries = index.config.wordBoundaries || false;\n\n  // Check for wildcard pattern\n  if (query.includes(\"*\")) {\n    // Wildcard search\n    for (const baseWord of index.base) {\n      if (matchesWildcard(baseWord, query)) {\n        if (!matches.has(baseWord)) {\n          matches.set(baseWord, {\n            word: baseWord,\n            normalized: query,\n            matchType: \"exact\",\n            editDistance: 0,\n            language,\n          });\n        }\n      }\n    }\n    return;\n  }\n\n  // Check for exact matches in the variant map (normalize to lowercase)\n  const exactMatches = index.variantToBase.get(query.toLowerCase());\n  if (exactMatches) {\n    exactMatches.forEach((word) => {\n      // With word boundaries, verify the match\n      if (wordBoundaries && !matchesWord(word, query, wordBoundaries)) {\n        return;\n      }\n\n      // Always add exact matches, even if already found with lower score\n      const existing = matches.get(word);\n      if (!existing || existing.matchType !== \"exact\") {\n        matches.set(word, {\n          word,\n          normalized: query,\n          matchType: \"exact\",\n          editDistance: 0,\n          language,\n        });\n      }\n    });\n  }\n\n  // Also check if the query exactly matches any base word (case-insensitive)\n  const queryLower = query.toLowerCase();\n  for (const baseWord of index.base) {\n    if (baseWord.toLowerCase() === queryLower) {\n      if (!matches.has(baseWord)) {\n        matches.set(baseWord, {\n          word: baseWord,\n          normalized: query,\n          matchType: \"exact\",\n          editDistance: 0,\n          language,\n        });\n      }\n    }\n  }\n}\n\n/**\n * Find prefix matches\n */\nfunction findPrefixMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>, language: string): void {\n  const wordBoundaries = index.config.wordBoundaries || false;\n  const queryLower = query.toLowerCase();\n\n  for (const [variant, words] of index.variantToBase.entries()) {\n    if (variant.startsWith(queryLower) && variant !== queryLower) {\n      words.forEach((word) => {\n        // With word boundaries, verify the match\n        if (wordBoundaries && !matchesWord(word, query, wordBoundaries)) {\n          return;\n        }\n\n        if (!matches.has(word)) {\n          matches.set(word, {\n            word,\n            normalized: variant,\n            matchType: \"prefix\",\n            language,\n          });\n        }\n      });\n    }\n  }\n}\n\n/**\n * Find phonetic matches\n */\nfunction findPhoneticMatches(query: string, processor: LanguageProcessor, index: FuzzyIndex, matches: Map<string, SearchMatch>): void {\n  if (!processor.supportedFeatures.includes(\"phonetic\")) return;\n\n  const phoneticCode = processor.getPhoneticCode(query);\n  if (phoneticCode) {\n    const phoneticMatches = index.phoneticToBase.get(phoneticCode);\n    if (phoneticMatches) {\n      phoneticMatches.forEach((word) => {\n        if (!matches.has(word)) {\n          matches.set(word, {\n            word,\n            normalized: query,\n            matchType: \"phonetic\",\n            phoneticCode,\n            language: processor.language,\n          });\n        }\n      });\n    }\n  }\n}\n\n/**\n * Find synonym matches\n */\nfunction findSynonymMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>): void {\n  const synonymMatches = index.synonymMap.get(query.toLowerCase());\n  if (synonymMatches) {\n    synonymMatches.forEach((word) => {\n      if (!matches.has(word)) {\n        matches.set(word, {\n          word,\n          normalized: query,\n          matchType: \"synonym\",\n          language: \"synonym\",\n        });\n      }\n    });\n  }\n}\n\n/**\n * Find n-gram matches\n */\nfunction findNgramMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>, language: string, ngramSize: number): void {\n  if (query.length < ngramSize) return;\n\n  const queryNgrams = generateNgrams(query, ngramSize);\n  const candidateWords = new Set<string>();\n\n  queryNgrams.forEach((ngram) => {\n    const ngramMatches = index.ngramIndex.get(ngram);\n    if (ngramMatches) {\n      ngramMatches.forEach((word) => candidateWords.add(word));\n    }\n  });\n\n  candidateWords.forEach((word) => {\n    if (!matches.has(word)) {\n      matches.set(word, {\n        word,\n        normalized: query,\n        matchType: \"ngram\",\n        language,\n      });\n    }\n  });\n}\n\n/**\n * Find fuzzy matches using edit distance\n */\nfunction findFuzzyMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>, processor: LanguageProcessor, config: FuzzyConfig): void {\n  const maxDistance = config.maxEditDistance;\n\n  for (const [variant, words] of index.variantToBase.entries()) {\n    if (Math.abs(variant.length - query.length) <= maxDistance) {\n      // Use Damerau-Levenshtein if transpositions feature is enabled\n      const useTranspositions = index.config.features?.includes(\"transpositions\");\n      const distance = useTranspositions ? calculateDamerauLevenshteinDistance(query, variant, maxDistance) : calculateLevenshteinDistance(query, variant, maxDistance);\n\n      if (distance <= maxDistance) {\n        words.forEach((word) => {\n          const existingMatch = matches.get(word);\n          // Don't replace exact or prefix matches with fuzzy matches\n          if (!existingMatch || (existingMatch.matchType !== \"exact\" && existingMatch.matchType !== \"prefix\" && (existingMatch.editDistance || Infinity) > distance)) {\n            matches.set(word, {\n              word,\n              normalized: variant,\n              matchType: \"fuzzy\",\n              editDistance: distance,\n              language: processor.language,\n            });\n          }\n        });\n      }\n    }\n  }\n}\n\n/**\n * Create a suggestion result from a search match\n */\nfunction createSuggestionResult(match: SearchMatch, originalQuery: string, threshold: number, index: FuzzyIndex, options?: SearchOptions): SuggestionResult | null {\n  let score = calculateMatchScore(match, originalQuery);\n\n  // Combine with BM25 score if available\n  if (match.bm25Score !== undefined && index.config.useBM25) {\n    const bm25Weight = index.config.bm25Weight || 0.6;\n    const fuzzyWeight = 1 - bm25Weight;\n    score = bm25Weight * match.bm25Score + fuzzyWeight * score;\n  }\n\n  // Apply field weight if present\n  if (match.fieldWeight) {\n    score = Math.min(1.0, score * match.fieldWeight);\n  }\n\n  if (score < threshold) {\n    return null;\n  }\n\n  // Calculate edit distance if not already available\n  let editDistance = match.editDistance;\n  if (editDistance === undefined) {\n    editDistance = calculateLevenshteinDistance(\n      originalQuery.toLowerCase(), \n      match.word.toLowerCase(), \n      Math.ceil(Math.max(originalQuery.length, match.word.length) * 0.5)\n    );\n  }\n\n  const result: SuggestionResult = {\n    display: match.word,\n    baseWord: match.word,\n    isSynonym: match.matchType === \"synonym\",\n    score,\n    language: match.language,\n    _editDistance: editDistance,\n    // @ts-ignore - temporary debug property\n    _debug_matchType: match.matchType,\n  };\n\n  // Add field information if this is a multi-field search\n  if (index.fieldData && index.fieldData.has(match.word)) {\n    result.fields = index.fieldData.get(match.word);\n    result.field = match.field;\n  }\n\n  // Add highlights if requested\n  if (options?.includeHighlights) {\n    result.highlights = calculateHighlights(match, originalQuery, match.word);\n  }\n\n  return result;\n}\n\n/**\n * Calculate match score (0-1, higher is better)\n * IMPROVED: Uses edit distance as primary metric for better fuzzy matching\n */\nfunction calculateMatchScore(\n  //\n  match: SearchMatch,\n  query: string\n): number {\n  const queryLen = query.length;\n  const wordLen = match.word.length;\n  const maxLen = Math.max(queryLen, wordLen);\n\n  // Calculate actual edit distance for all match types (if not already provided)\n  let editDistance = match.editDistance;\n  if (editDistance === undefined) {\n    // Calculate edit distance for non-fuzzy matches to enable better comparison\n    editDistance = calculateLevenshteinDistance(query.toLowerCase(), match.word.toLowerCase(), Math.ceil(maxLen * 0.5));\n  }\n\n  let score = 0.5; // Base score\n\n  // PRIMARY METRIC: Edit distance-based scoring\n  // Lower edit distance = higher score, regardless of match type\n  const editDistanceScore = Math.max(0, 1.0 - editDistance / maxLen);\n\n  switch (match.matchType) {\n    case \"exact\":\n      score = 1.0;\n      break;\n    case \"prefix\":\n      // Penalize prefix matches on words much longer than query\n      // Use edit distance to differentiate quality of prefix matches\n      const lengthPenalty = Math.max(0, (wordLen - queryLen) / maxLen);\n      score = 0.9 - lengthPenalty * 0.3;\n      // Boost if edit distance is very low (close match)\n      if (editDistance <= 2) {\n        score = Math.max(score, editDistanceScore * 0.95);\n      }\n      break;\n    case \"substring\":\n      score = 0.8;\n      break;\n    case \"phonetic\":\n      // Phonetic matches should consider edit distance too\n      score = Math.max(0.7, editDistanceScore * 0.85);\n      break;\n    case \"fuzzy\":\n      // Fuzzy matches prioritize edit distance heavily\n      score = Math.max(0.3, editDistanceScore);\n      // Boost fuzzy matches with very low edit distance (1-2 chars off)\n      if (editDistance <= 2) {\n        score = Math.min(1.0, score + 0.1);\n      }\n      break;\n    case \"synonym\":\n      score = 0.6;\n      break;\n    case \"compound\":\n      score = 0.75;\n      break;\n    case \"ngram\":\n      score = calculateNgramSimilarity(query.toLowerCase(), match.normalized, 3) * 0.8;\n      break;\n  }\n\n  // Length-based adjustments (apply to ALL match types)\n  // Penalize matches that are much longer than the query (likely false positives)\n  // Even \"exact\" matches should be penalized if word is much longer (substring in longer word)\n  if (wordLen > queryLen * 2) {\n    score *= 0.6;\n  }\n  \n  // Boost matches close to query length (more likely to be what user wants)\n  if (Math.abs(wordLen - queryLen) <= 2 && match.matchType !== \"exact\") {\n    score = Math.min(1.0, score + 0.05);\n  }\n\n  return Math.min(1.0, Math.max(0.0, score));\n}\n\n/**\n * Generate n-grams from a string\n */\nfunction generateNgrams(\n  //\n  str: string,\n  n: number\n): string[] {\n  if (str.length < n) return [str];\n\n  const ngrams: string[] = [];\n  for (let i = 0; i <= str.length - n; i++) {\n    ngrams.push(str.slice(i, i + n));\n  }\n  return ngrams;\n}\n\n/**\n * Get suggestions using inverted index (for large datasets)\n * This is a wrapper that converts inverted index results to the same format\n */\nfunction getSuggestionsInverted(\n  //\n  index: FuzzyIndex,\n  query: string,\n  limit: number,\n  threshold: number,\n  processors: LanguageProcessor[],\n  options?: SearchOptions\n): SuggestionResult[] {\n  if (!index.invertedIndex || !index.documents) {\n    throw new Error(\"Inverted index not available\");\n  }\n\n  // Use inverted index search\n  let matches = searchInvertedIndex(index.invertedIndex, index.documents, query, processors, index.config);\n\n  // Calculate BM25 scores if enabled\n  if (index.config.useBM25) {\n    const queryTerms = query.toLowerCase().split(/\\s+/).filter(t => t.length > 0);\n    matches = calculateBM25Scores(matches, queryTerms, index.invertedIndex, index.documents, index.config);\n  }\n\n  // Convert to suggestion results (same as classic approach)\n  let results = matches\n    .map((match) => createSuggestionResult(match, query, threshold, index, options))\n    .filter((result): result is SuggestionResult => result !== null);\n\n  // Apply filters if provided\n  if (options?.filters) {\n    results = applyFilters(results, options.filters);\n  }\n\n  // Apply custom sorting if provided\n  if (options?.sort) {\n    results = applySorting(results, options.sort);\n  } else {\n    // Default: sort by relevance\n    results = results.sort((a, b) => b.score - a.score);\n  }\n\n  // Limit results\n  results = results.slice(0, limit);\n\n  return results;\n}\n\n/**\n * Search with phrase support\n * Handles queries containing quoted phrases\n */\nfunction searchWithPhrases(\n  index: FuzzyIndex,\n  parsedQuery: ReturnType<typeof parseQuery>,\n  limit: number,\n  threshold: number,\n  options: SearchOptions\n): SuggestionResult[] {\n  const config = index.config;\n  const useTranspositions = config.features.includes('transpositions');\n  \n  // Get phrase match options\n  const phraseOptions = {\n    exactMatch: false,\n    maxEditDistance: 1,\n    proximityBonus: 1.5,\n    maxProximityDistance: 3,\n    useTranspositions,\n  };\n\n  // Search all base words for phrase matches\n  const phraseMatches = new Map<string, { score: number; phraseCount: number }>();\n\n  // For each phrase, find matching words\n  for (const phrase of parsedQuery.phrases) {\n    for (const word of index.base) {\n      const match = matchPhrase(word, phrase, phraseOptions);\n      \n      if (match.matched) {\n        const existing = phraseMatches.get(word);\n        const newScore = match.score * phraseOptions.proximityBonus;\n        \n        if (existing) {\n          // Multiple phrases matched - boost even more\n          phraseMatches.set(word, {\n            score: Math.max(existing.score, newScore),\n            phraseCount: existing.phraseCount + 1,\n          });\n        } else {\n          phraseMatches.set(word, { score: newScore, phraseCount: 1 });\n        }\n      }\n    }\n  }\n\n  // If we have regular terms too, search for them\n  let termMatches = new Map<string, SearchMatch>();\n  \n  if (parsedQuery.terms.length > 0) {\n    const termQuery = parsedQuery.terms.join(' ');\n    const processors = config.languages\n      .map((lang) => index.languageProcessors.get(lang))\n      .filter((p): p is LanguageProcessor => p !== undefined);\n\n    for (const processor of processors) {\n      const normalizedQuery = processor.normalize(termQuery);\n      \n      // Use existing search strategies for terms\n      findExactMatches(normalizedQuery, index, termMatches, processor.language);\n      findPrefixMatches(normalizedQuery, index, termMatches, processor.language);\n      findPhoneticMatches(normalizedQuery, processor, index, termMatches);\n      findNgramMatches(normalizedQuery, index, termMatches, processor.language, config.ngramSize);\n      \n      if (config.features.includes(\"missing-letters\") || config.features.includes(\"extra-letters\") || config.features.includes(\"transpositions\")) {\n        findFuzzyMatches(normalizedQuery, index, termMatches, processor, config);\n      }\n    }\n  }\n\n  // Combine phrase and term matches\n  const combinedResults = new Map<string, SuggestionResult>();\n\n  // Add phrase matches\n  for (const [word, phraseData] of phraseMatches.entries()) {\n    const result: SuggestionResult = {\n      display: word,\n      baseWord: word,\n      isSynonym: false,\n      score: phraseData.score,\n    };\n    \n    // If word also matched terms, boost score even more\n    const termMatch = termMatches.get(word);\n    if (termMatch) {\n      result.score = Math.min(1.0, result.score * 1.2);\n    }\n    \n    combinedResults.set(word, result);\n  }\n\n  // Add term matches that didn't match phrases (with lower priority)\n  for (const [word, match] of termMatches.entries()) {\n    if (!combinedResults.has(word)) {\n      const result = createSuggestionResult(match, parsedQuery.terms.join(' '), threshold, index, options);\n      if (result) {\n        // Reduce score slightly since it didn't match the phrase\n        result.score *= 0.8;\n        combinedResults.set(word, result);\n      }\n    }\n  }\n\n  // Sort and limit results\n  const results = Array.from(combinedResults.values())\n    .filter(r => r.score >= threshold)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, limit);\n\n  // Cache the results\n  if (index._cache) {\n    index._cache.set(parsedQuery.original, results, limit, options);\n  }\n\n  return results;\n}\n\n/**\n * Update an existing index by adding new items\n * Much faster than rebuilding the entire index\n * \n * @param index - Existing fuzzy index to update\n * @param newItems - New items to add (strings or objects)\n * @param options - Optional configuration (uses index's existing config by default)\n * @returns Updated index (mutates the original)\n * \n * @example\n * const index = buildFuzzyIndex(['apple', 'banana']);\n * updateIndex(index, ['cherry', 'date']);\n * // Index now contains: apple, banana, cherry, date\n */\nexport function updateIndex(\n  index: FuzzyIndex,\n  newItems: (string | any)[] = [],\n  options: Partial<BuildIndexOptions> = {}\n): FuzzyIndex {\n  if (!index || !index.config) {\n    throw new Error('Invalid index provided');\n  }\n\n  if (!newItems || newItems.length === 0) {\n    return index;\n  }\n\n  // Use existing index configuration\n  const config = index.config;\n  const featureSet = new Set(config.features);\n  \n  // Get language processors from index\n  const languageProcessors = Array.from(index.languageProcessors.values());\n  \n  if (languageProcessors.length === 0) {\n    throw new Error('No language processors found in index');\n  }\n\n  // Check if we're doing multi-field search\n  const hasFields = index.fields && index.fields.length > 0;\n  const isObjectArray = newItems.length > 0 && typeof newItems[0] === 'object' && newItems[0] !== null;\n\n  // Validate: if objects are provided, fields must be specified\n  if (isObjectArray && !hasFields) {\n    throw new Error('Index was not built with fields, cannot add objects');\n  }\n\n  // Track existing words to avoid duplicates\n  const existingWords = new Set(index.base.map(w => w.toLowerCase()));\n  let processed = 0;\n\n  for (const item of newItems) {\n    if (!item) continue;\n\n    // Handle multi-field objects\n    if (hasFields && isObjectArray) {\n      const fieldValues = extractFieldValues(item, index.fields);\n      if (!fieldValues) continue;\n\n      // Generate a unique ID for this object\n      const baseId = Object.values(fieldValues)[0] || `item_${index.base.length + processed}`;\n\n      // Skip if already exists\n      if (existingWords.has(baseId.toLowerCase())) continue;\n\n      // Store field data\n      if (index.fieldData) {\n        index.fieldData.set(baseId, fieldValues);\n      }\n\n      // Add to base\n      existingWords.add(baseId.toLowerCase());\n      index.base.push(baseId);\n\n      // Index each field separately\n      for (const [fieldName, fieldValue] of Object.entries(fieldValues)) {\n        if (!fieldValue || fieldValue.trim().length < config.minQueryLength) continue;\n\n        const trimmedValue = fieldValue.trim();\n\n        // Process this field value with each language processor\n        for (const processor of languageProcessors) {\n          processWordWithProcessorAndField(trimmedValue, baseId, fieldName, processor, index, config, featureSet);\n        }\n      }\n    } else {\n      // Handle simple string array\n      const word = typeof item === 'string' ? item : String(item);\n      if (word.trim().length < config.minQueryLength) continue;\n\n      const trimmedWord = word.trim();\n      \n      // Skip if already exists\n      if (existingWords.has(trimmedWord.toLowerCase())) continue;\n\n      existingWords.add(trimmedWord.toLowerCase());\n      index.base.push(trimmedWord);\n\n      // Process with each language processor\n      for (const processor of languageProcessors) {\n        processWordWithProcessor(trimmedWord, processor, index, config, featureSet);\n      }\n    }\n\n    processed++;\n    if (options.onProgress) {\n      options.onProgress(processed, newItems.length);\n    }\n  }\n\n  // Update inverted index if it exists\n  if (index.invertedIndex && index.documents) {\n    const { invertedIndex, documents } = buildInvertedIndex(\n      index.base,\n      languageProcessors,\n      config,\n      featureSet\n    );\n    index.invertedIndex = invertedIndex;\n    index.documents = documents;\n  }\n\n  // Clear cache since index has changed\n  if (index._cache) {\n    index._cache.clear();\n  }\n\n  return index;\n}\n\n/**\n * Remove items from an existing index\n * \n * @param index - Existing fuzzy index to update\n * @param itemsToRemove - Items to remove (exact matches)\n * @returns Updated index (mutates the original)\n * \n * @example\n * const index = buildFuzzyIndex(['apple', 'banana', 'cherry']);\n * removeFromIndex(index, ['banana']);\n * // Index now contains: apple, cherry\n */\nexport function removeFromIndex(\n  index: FuzzyIndex,\n  itemsToRemove: string[] = []\n): FuzzyIndex {\n  if (!index || !index.config) {\n    throw new Error('Invalid index provided');\n  }\n\n  if (!itemsToRemove || itemsToRemove.length === 0) {\n    return index;\n  }\n\n  // Create set of items to remove (case-insensitive)\n  const toRemove = new Set(itemsToRemove.map(item => item.toLowerCase()));\n\n  // Remove from base array\n  index.base = index.base.filter(word => !toRemove.has(word.toLowerCase()));\n\n  // Remove from variant maps\n  for (const [variant, baseWords] of index.variantToBase.entries()) {\n    const filtered = new Set(Array.from(baseWords).filter((word: string) => !toRemove.has(word.toLowerCase())));\n    if (filtered.size === 0) {\n      index.variantToBase.delete(variant);\n    } else {\n      index.variantToBase.set(variant, filtered);\n    }\n  }\n\n  // Remove from phonetic map\n  for (const [phonetic, baseWords] of index.phoneticToBase.entries()) {\n    const filtered = new Set(Array.from(baseWords).filter((word: string) => !toRemove.has(word.toLowerCase())));\n    if (filtered.size === 0) {\n      index.phoneticToBase.delete(phonetic);\n    } else {\n      index.phoneticToBase.set(phonetic, filtered);\n    }\n  }\n\n  // Remove from ngram index\n  for (const [ngram, baseWords] of index.ngramIndex.entries()) {\n    const filtered = new Set(Array.from(baseWords).filter((word: string) => !toRemove.has(word.toLowerCase())));\n    if (filtered.size === 0) {\n      index.ngramIndex.delete(ngram);\n    } else {\n      index.ngramIndex.set(ngram, filtered);\n    }\n  }\n\n  // Remove from synonym map\n  for (const [synonym, baseWords] of index.synonymMap.entries()) {\n    const filtered = new Set(Array.from(baseWords).filter((word: string) => !toRemove.has(word.toLowerCase())));\n    if (filtered.size === 0) {\n      index.synonymMap.delete(synonym);\n    } else {\n      index.synonymMap.set(synonym, filtered);\n    }\n  }\n\n  // Remove from field data if exists\n  if (index.fieldData) {\n    for (const item of itemsToRemove) {\n      index.fieldData.delete(item);\n    }\n  }\n\n  // Rebuild inverted index if it exists\n  if (index.invertedIndex && index.documents) {\n    const config = index.config;\n    const featureSet = new Set(config.features);\n    const languageProcessors = Array.from(index.languageProcessors.values());\n    \n    const { invertedIndex, documents } = buildInvertedIndex(\n      index.base,\n      languageProcessors,\n      config,\n      featureSet\n    );\n    index.invertedIndex = invertedIndex;\n    index.documents = documents;\n  }\n\n  // Clear cache since index has changed\n  if (index._cache) {\n    index._cache.clear();\n  }\n\n  return index;\n}\n"],"names":["results"],"mappings":"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"}