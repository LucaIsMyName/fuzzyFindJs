{"version":3,"file":"inverted-index.js","sources":["../../../src/core/inverted-index.ts"],"sourcesContent":["/**\n * Inverted Index Implementation\n * Optimized for large datasets (1M+ words)\n *\n * Architecture:\n * - Token â†’ [docId1, docId2, ...] (posting lists)\n * - Fast intersection/union operations\n * - BM25-like scoring for relevance\n * - Parallel to existing hash-based index (backwards compatible)\n */\n\nimport type {\n  //\n  InvertedIndex,\n  DocumentMetadata,\n  PostingList,\n  FuzzyConfig,\n  LanguageProcessor,\n  SearchMatch,\n} from \"./types.js\";\nimport {\n  //\n  calculateLevenshteinDistance,\n} from \"../algorithms/levenshtein.js\";\n\n/**\n * Build inverted index from documents\n * This runs ALONGSIDE the existing index building\n */\nexport function buildInvertedIndex(words: string[], languageProcessors: LanguageProcessor[], config: FuzzyConfig, featureSet: Set<string>): { invertedIndex: InvertedIndex; documents: DocumentMetadata[] } {\n  const documents: DocumentMetadata[] = [];\n  const invertedIndex: InvertedIndex = {\n    termToPostings: new Map(),\n    phoneticToPostings: new Map(),\n    ngramToPostings: new Map(),\n    synonymToPostings: new Map(),\n    fieldIndices: new Map(),\n    totalDocs: 0,\n    avgDocLength: 0,\n  };\n\n  let totalLength = 0;\n  let docId = 0;\n\n  // Build documents and posting lists\n  for (const word of words) {\n    if (!word || word.trim().length < config.minQueryLength) continue;\n\n    const trimmedWord = word.trim();\n\n    // Process with each language processor\n    for (const processor of languageProcessors) {\n      const normalized = processor.normalize(trimmedWord);\n      const phoneticCode = featureSet.has(\"phonetic\") && processor.supportedFeatures.includes(\"phonetic\") ? processor.getPhoneticCode(trimmedWord) : undefined;\n\n      const compoundParts = featureSet.has(\"compound\") && processor.supportedFeatures.includes(\"compound\") ? processor.splitCompoundWords(trimmedWord) : undefined;\n\n      // Create document metadata\n      const doc: DocumentMetadata = {\n        id: docId,\n        word: trimmedWord,\n        normalized,\n        phoneticCode,\n        language: processor.language,\n        compoundParts: compoundParts && compoundParts.length > 1 ? compoundParts : undefined,\n      };\n\n      documents.push(doc);\n      totalLength += normalized.length;\n\n      // Index the normalized term\n      addToPostingList(invertedIndex.termToPostings, normalized, docId);\n\n      // Index original word (for exact matching)\n      addToPostingList(invertedIndex.termToPostings, trimmedWord.toLowerCase(), docId);\n\n      // Index word variants (prefixes)\n      if (featureSet.has(\"partial-words\")) {\n        const variants = processor.getWordVariants(trimmedWord);\n        variants.forEach((variant) => {\n          addToPostingList(invertedIndex.termToPostings, variant, docId);\n        });\n      }\n\n      // Index phonetic code\n      if (phoneticCode) {\n        addToPostingList(invertedIndex.phoneticToPostings, phoneticCode, docId);\n      }\n\n      // Index n-grams\n      const ngrams = generateNgrams(normalized, config.ngramSize);\n      ngrams.forEach((ngram) => {\n        addToPostingList(invertedIndex.ngramToPostings, ngram, docId);\n      });\n\n      // Index compound parts\n      if (compoundParts && compoundParts.length > 1) {\n        compoundParts.forEach((part) => {\n          const normalizedPart = processor.normalize(part);\n          addToPostingList(invertedIndex.termToPostings, normalizedPart, docId);\n        });\n      }\n\n      // Index synonyms\n      if (featureSet.has(\"synonyms\")) {\n        const synonyms = processor.getSynonyms(normalized);\n        synonyms.forEach((synonym) => {\n          addToPostingList(invertedIndex.synonymToPostings, synonym, docId);\n        });\n\n        // Custom synonyms\n        if (config.customSynonyms) {\n          const customSynonyms = config.customSynonyms[normalized];\n          if (customSynonyms) {\n            customSynonyms.forEach((synonym) => {\n              addToPostingList(invertedIndex.synonymToPostings, synonym, docId);\n            });\n          }\n        }\n      }\n\n      docId++;\n    }\n  }\n\n  invertedIndex.totalDocs = docId;\n  invertedIndex.avgDocLength = totalLength / Math.max(1, docId);\n\n  return { invertedIndex, documents };\n}\n\n/**\n * Search using inverted index\n * Much faster than hash-based approach for large datasets\n */\nexport function searchInvertedIndex(invertedIndex: InvertedIndex, documents: DocumentMetadata[], query: string, processors: LanguageProcessor[], config: FuzzyConfig): SearchMatch[] {\n  const matches = new Map<number, SearchMatch>();\n  const featureSet = new Set(config.features);\n\n  // Process query with each language processor\n  for (const processor of processors) {\n    const normalizedQuery = processor.normalize(query.trim());\n\n    // 1. Exact term lookup (fastest)\n    findExactMatchesInverted(normalizedQuery, invertedIndex, documents, matches, processor.language);\n\n    // 2. Prefix matches\n    findPrefixMatchesInverted(normalizedQuery, invertedIndex, documents, matches, processor.language);\n\n    // 3. Phonetic matches\n    if (featureSet.has(\"phonetic\") && processor.supportedFeatures.includes(\"phonetic\")) {\n      findPhoneticMatchesInverted(normalizedQuery, processor, invertedIndex, documents, matches);\n    }\n\n    // 4. Synonym matches\n    if (featureSet.has(\"synonyms\")) {\n      findSynonymMatchesInverted(normalizedQuery, invertedIndex, documents, matches);\n    }\n\n    // 5. N-gram matches\n    findNgramMatchesInverted(normalizedQuery, invertedIndex, documents, matches, processor.language, config.ngramSize);\n\n    // 6. Fuzzy matches (most expensive, do last)\n    if (featureSet.has(\"missing-letters\") || featureSet.has(\"extra-letters\") || featureSet.has(\"transpositions\")) {\n      findFuzzyMatchesInverted(normalizedQuery, invertedIndex, documents, matches, processor, config.maxEditDistance);\n    }\n  }\n\n  // Convert to array and return\n  return Array.from(matches.values());\n}\n\n/**\n * Helper: Add document to posting list\n */\nfunction addToPostingList(postings: Map<string, PostingList>, term: string, docId: number): void {\n  let posting = postings.get(term);\n  if (!posting) {\n    posting = { term, docIds: [] };\n    postings.set(term, posting);\n  }\n\n  // Avoid duplicates\n  if (!posting.docIds.includes(docId)) {\n    posting.docIds.push(docId);\n  }\n}\n\n/**\n * Helper: Generate n-grams\n */\nfunction generateNgrams(str: string, n: number): string[] {\n  if (str.length < n) return [str];\n  const ngrams: string[] = [];\n  for (let i = 0; i <= str.length - n; i++) {\n    ngrams.push(str.slice(i, i + n));\n  }\n  return ngrams;\n}\n\n/**\n * Find exact matches in inverted index\n */\nfunction findExactMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>, language: string): void {\n  const posting = invertedIndex.termToPostings.get(query);\n  if (!posting) return;\n\n  posting.docIds.forEach((docId) => {\n    const doc = documents[docId];\n    if (!doc) return;\n\n    if (!matches.has(docId)) {\n      matches.set(docId, {\n        word: doc.word,\n        normalized: query,\n        matchType: \"exact\",\n        editDistance: 0,\n        language,\n      });\n    }\n  });\n}\n\n/**\n * Find prefix matches in inverted index\n */\nfunction findPrefixMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>, language: string): void {\n  // Iterate through all terms and check for prefix\n  // Note: This could be optimized with a Trie, but for now we keep it simple\n  for (const [term, posting] of invertedIndex.termToPostings.entries()) {\n    if (term.startsWith(query) && term !== query) {\n      posting.docIds.forEach((docId) => {\n        const doc = documents[docId];\n        if (!doc) return;\n\n        if (!matches.has(docId)) {\n          matches.set(docId, {\n            word: doc.word,\n            normalized: term,\n            matchType: \"prefix\",\n            language,\n          });\n        }\n      });\n    }\n  }\n}\n\n/**\n * Find phonetic matches in inverted index\n */\nfunction findPhoneticMatchesInverted(query: string, processor: LanguageProcessor, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>): void {\n  const phoneticCode = processor.getPhoneticCode(query);\n  if (!phoneticCode) return;\n\n  const posting = invertedIndex.phoneticToPostings.get(phoneticCode);\n  if (!posting) return;\n\n  posting.docIds.forEach((docId) => {\n    const doc = documents[docId];\n    if (!doc) return;\n\n    if (!matches.has(docId)) {\n      matches.set(docId, {\n        word: doc.word,\n        normalized: query,\n        matchType: \"phonetic\",\n        phoneticCode,\n        language: processor.language,\n      });\n    }\n  });\n}\n\n/**\n * Find synonym matches in inverted index\n */\nfunction findSynonymMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>): void {\n  const posting = invertedIndex.synonymToPostings.get(query);\n  if (!posting) return;\n\n  posting.docIds.forEach((docId) => {\n    const doc = documents[docId];\n    if (!doc) return;\n\n    if (!matches.has(docId)) {\n      matches.set(docId, {\n        word: doc.word,\n        normalized: query,\n        matchType: \"synonym\",\n        language: \"synonym\",\n      });\n    }\n  });\n}\n\n/**\n * Find n-gram matches in inverted index\n */\nfunction findNgramMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>, language: string, ngramSize: number): void {\n  if (query.length < ngramSize) return;\n\n  const queryNgrams = generateNgrams(query, ngramSize);\n  const candidateDocs = new Set<number>();\n\n  // Collect all documents that contain at least one n-gram\n  queryNgrams.forEach((ngram) => {\n    const posting = invertedIndex.ngramToPostings.get(ngram);\n    if (posting) {\n      posting.docIds.forEach((docId) => candidateDocs.add(docId));\n    }\n  });\n\n  // Add to matches\n  candidateDocs.forEach((docId) => {\n    const doc = documents[docId];\n    if (!doc) return;\n\n    if (!matches.has(docId)) {\n      matches.set(docId, {\n        word: doc.word,\n        normalized: query,\n        matchType: \"ngram\",\n        language,\n      });\n    }\n  });\n}\n\n/**\n * Find fuzzy matches in inverted index\n * This is still O(n) but with better cache locality\n */\nfunction findFuzzyMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>, processor: LanguageProcessor, maxDistance: number): void {\n  // Iterate through all terms\n  for (const [term, posting] of invertedIndex.termToPostings.entries()) {\n    // Quick length check\n    if (Math.abs(term.length - query.length) > maxDistance) continue;\n\n    const distance = calculateLevenshteinDistance(query, term, maxDistance);\n    if (distance <= maxDistance) {\n      posting.docIds.forEach((docId) => {\n        const doc = documents[docId];\n        if (!doc) return;\n\n        const existingMatch = matches.get(docId);\n        if (!existingMatch || (existingMatch.editDistance || Infinity) > distance) {\n          matches.set(docId, {\n            word: doc.word,\n            normalized: term,\n            matchType: \"fuzzy\",\n            editDistance: distance,\n            language: processor.language,\n          });\n        }\n      });\n    }\n  }\n}\n"],"names":[],"mappings":";AA6BO,SAAS,mBAAmB,OAAiB,oBAAyC,QAAqB,YAA0F;AAC1M,QAAM,YAAgC,CAAA;AACtC,QAAM,gBAA+B;AAAA,IACnC,oCAAoB,IAAA;AAAA,IACpB,wCAAwB,IAAA;AAAA,IACxB,qCAAqB,IAAA;AAAA,IACrB,uCAAuB,IAAA;AAAA,IACvB,kCAAkB,IAAA;AAAA,IAClB,WAAW;AAAA,IACX,cAAc;AAAA,EAAA;AAGhB,MAAI,cAAc;AAClB,MAAI,QAAQ;AAGZ,aAAW,QAAQ,OAAO;AACxB,QAAI,CAAC,QAAQ,KAAK,OAAO,SAAS,OAAO,eAAgB;AAEzD,UAAM,cAAc,KAAK,KAAA;AAGzB,eAAW,aAAa,oBAAoB;AAC1C,YAAM,aAAa,UAAU,UAAU,WAAW;AAClD,YAAM,eAAe,WAAW,IAAI,UAAU,KAAK,UAAU,kBAAkB,SAAS,UAAU,IAAI,UAAU,gBAAgB,WAAW,IAAI;AAE/I,YAAM,gBAAgB,WAAW,IAAI,UAAU,KAAK,UAAU,kBAAkB,SAAS,UAAU,IAAI,UAAU,mBAAmB,WAAW,IAAI;AAGnJ,YAAM,MAAwB;AAAA,QAC5B,IAAI;AAAA,QACJ,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA,UAAU,UAAU;AAAA,QACpB,eAAe,iBAAiB,cAAc,SAAS,IAAI,gBAAgB;AAAA,MAAA;AAG7E,gBAAU,KAAK,GAAG;AAClB,qBAAe,WAAW;AAG1B,uBAAiB,cAAc,gBAAgB,YAAY,KAAK;AAGhE,uBAAiB,cAAc,gBAAgB,YAAY,YAAA,GAAe,KAAK;AAG/E,UAAI,WAAW,IAAI,eAAe,GAAG;AACnC,cAAM,WAAW,UAAU,gBAAgB,WAAW;AACtD,iBAAS,QAAQ,CAAC,YAAY;AAC5B,2BAAiB,cAAc,gBAAgB,SAAS,KAAK;AAAA,QAC/D,CAAC;AAAA,MACH;AAGA,UAAI,cAAc;AAChB,yBAAiB,cAAc,oBAAoB,cAAc,KAAK;AAAA,MACxE;AAGA,YAAM,SAAS,eAAe,YAAY,OAAO,SAAS;AAC1D,aAAO,QAAQ,CAAC,UAAU;AACxB,yBAAiB,cAAc,iBAAiB,OAAO,KAAK;AAAA,MAC9D,CAAC;AAGD,UAAI,iBAAiB,cAAc,SAAS,GAAG;AAC7C,sBAAc,QAAQ,CAAC,SAAS;AAC9B,gBAAM,iBAAiB,UAAU,UAAU,IAAI;AAC/C,2BAAiB,cAAc,gBAAgB,gBAAgB,KAAK;AAAA,QACtE,CAAC;AAAA,MACH;AAGA,UAAI,WAAW,IAAI,UAAU,GAAG;AAC9B,cAAM,WAAW,UAAU,YAAY,UAAU;AACjD,iBAAS,QAAQ,CAAC,YAAY;AAC5B,2BAAiB,cAAc,mBAAmB,SAAS,KAAK;AAAA,QAClE,CAAC;AAGD,YAAI,OAAO,gBAAgB;AACzB,gBAAM,iBAAiB,OAAO,eAAe,UAAU;AACvD,cAAI,gBAAgB;AAClB,2BAAe,QAAQ,CAAC,YAAY;AAClC,+BAAiB,cAAc,mBAAmB,SAAS,KAAK;AAAA,YAClE,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAEA;AAAA,IACF;AAAA,EACF;AAEA,gBAAc,YAAY;AAC1B,gBAAc,eAAe,cAAc,KAAK,IAAI,GAAG,KAAK;AAE5D,SAAO,EAAE,eAAe,UAAA;AAC1B;AAMO,SAAS,oBAAoB,eAA8B,WAA+B,OAAe,YAAiC,QAAoC;AACnL,QAAM,8BAAc,IAAA;AACpB,QAAM,aAAa,IAAI,IAAI,OAAO,QAAQ;AAG1C,aAAW,aAAa,YAAY;AAClC,UAAM,kBAAkB,UAAU,UAAU,MAAM,MAAM;AAGxD,6BAAyB,iBAAiB,eAAe,WAAW,SAAS,UAAU,QAAQ;AAG/F,8BAA0B,iBAAiB,eAAe,WAAW,SAAS,UAAU,QAAQ;AAGhG,QAAI,WAAW,IAAI,UAAU,KAAK,UAAU,kBAAkB,SAAS,UAAU,GAAG;AAClF,kCAA4B,iBAAiB,WAAW,eAAe,WAAW,OAAO;AAAA,IAC3F;AAGA,QAAI,WAAW,IAAI,UAAU,GAAG;AAC9B,iCAA2B,iBAAiB,eAAe,WAAW,OAAO;AAAA,IAC/E;AAGA,6BAAyB,iBAAiB,eAAe,WAAW,SAAS,UAAU,UAAU,OAAO,SAAS;AAGjH,QAAI,WAAW,IAAI,iBAAiB,KAAK,WAAW,IAAI,eAAe,KAAK,WAAW,IAAI,gBAAgB,GAAG;AAC5G,+BAAyB,iBAAiB,eAAe,WAAW,SAAS,WAAW,OAAO,eAAe;AAAA,IAChH;AAAA,EACF;AAGA,SAAO,MAAM,KAAK,QAAQ,OAAA,CAAQ;AACpC;AAKA,SAAS,iBAAiB,UAAoC,MAAc,OAAqB;AAC/F,MAAI,UAAU,SAAS,IAAI,IAAI;AAC/B,MAAI,CAAC,SAAS;AACZ,cAAU,EAAE,MAAM,QAAQ,GAAC;AAC3B,aAAS,IAAI,MAAM,OAAO;AAAA,EAC5B;AAGA,MAAI,CAAC,QAAQ,OAAO,SAAS,KAAK,GAAG;AACnC,YAAQ,OAAO,KAAK,KAAK;AAAA,EAC3B;AACF;AAKA,SAAS,eAAe,KAAa,GAAqB;AACxD,MAAI,IAAI,SAAS,EAAG,QAAO,CAAC,GAAG;AAC/B,QAAM,SAAmB,CAAA;AACzB,WAAS,IAAI,GAAG,KAAK,IAAI,SAAS,GAAG,KAAK;AACxC,WAAO,KAAK,IAAI,MAAM,GAAG,IAAI,CAAC,CAAC;AAAA,EACjC;AACA,SAAO;AACT;AAKA,SAAS,yBAAyB,OAAe,eAA8B,WAA+B,SAAmC,UAAwB;AACvK,QAAM,UAAU,cAAc,eAAe,IAAI,KAAK;AACtD,MAAI,CAAC,QAAS;AAEd,UAAQ,OAAO,QAAQ,CAAC,UAAU;AAChC,UAAM,MAAM,UAAU,KAAK;AAC3B,QAAI,CAAC,IAAK;AAEV,QAAI,CAAC,QAAQ,IAAI,KAAK,GAAG;AACvB,cAAQ,IAAI,OAAO;AAAA,QACjB,MAAM,IAAI;AAAA,QACV,YAAY;AAAA,QACZ,WAAW;AAAA,QACX,cAAc;AAAA,QACd;AAAA,MAAA,CACD;AAAA,IACH;AAAA,EACF,CAAC;AACH;AAKA,SAAS,0BAA0B,OAAe,eAA8B,WAA+B,SAAmC,UAAwB;AAGxK,aAAW,CAAC,MAAM,OAAO,KAAK,cAAc,eAAe,WAAW;AACpE,QAAI,KAAK,WAAW,KAAK,KAAK,SAAS,OAAO;AAC5C,cAAQ,OAAO,QAAQ,CAAC,UAAU;AAChC,cAAM,MAAM,UAAU,KAAK;AAC3B,YAAI,CAAC,IAAK;AAEV,YAAI,CAAC,QAAQ,IAAI,KAAK,GAAG;AACvB,kBAAQ,IAAI,OAAO;AAAA,YACjB,MAAM,IAAI;AAAA,YACV,YAAY;AAAA,YACZ,WAAW;AAAA,YACX;AAAA,UAAA,CACD;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF;AAKA,SAAS,4BAA4B,OAAe,WAA8B,eAA8B,WAA+B,SAAyC;AACtL,QAAM,eAAe,UAAU,gBAAgB,KAAK;AACpD,MAAI,CAAC,aAAc;AAEnB,QAAM,UAAU,cAAc,mBAAmB,IAAI,YAAY;AACjE,MAAI,CAAC,QAAS;AAEd,UAAQ,OAAO,QAAQ,CAAC,UAAU;AAChC,UAAM,MAAM,UAAU,KAAK;AAC3B,QAAI,CAAC,IAAK;AAEV,QAAI,CAAC,QAAQ,IAAI,KAAK,GAAG;AACvB,cAAQ,IAAI,OAAO;AAAA,QACjB,MAAM,IAAI;AAAA,QACV,YAAY;AAAA,QACZ,WAAW;AAAA,QACX;AAAA,QACA,UAAU,UAAU;AAAA,MAAA,CACrB;AAAA,IACH;AAAA,EACF,CAAC;AACH;AAKA,SAAS,2BAA2B,OAAe,eAA8B,WAA+B,SAAyC;AACvJ,QAAM,UAAU,cAAc,kBAAkB,IAAI,KAAK;AACzD,MAAI,CAAC,QAAS;AAEd,UAAQ,OAAO,QAAQ,CAAC,UAAU;AAChC,UAAM,MAAM,UAAU,KAAK;AAC3B,QAAI,CAAC,IAAK;AAEV,QAAI,CAAC,QAAQ,IAAI,KAAK,GAAG;AACvB,cAAQ,IAAI,OAAO;AAAA,QACjB,MAAM,IAAI;AAAA,QACV,YAAY;AAAA,QACZ,WAAW;AAAA,QACX,UAAU;AAAA,MAAA,CACX;AAAA,IACH;AAAA,EACF,CAAC;AACH;AAKA,SAAS,yBAAyB,OAAe,eAA8B,WAA+B,SAAmC,UAAkB,WAAyB;AAC1L,MAAI,MAAM,SAAS,UAAW;AAE9B,QAAM,cAAc,eAAe,OAAO,SAAS;AACnD,QAAM,oCAAoB,IAAA;AAG1B,cAAY,QAAQ,CAAC,UAAU;AAC7B,UAAM,UAAU,cAAc,gBAAgB,IAAI,KAAK;AACvD,QAAI,SAAS;AACX,cAAQ,OAAO,QAAQ,CAAC,UAAU,cAAc,IAAI,KAAK,CAAC;AAAA,IAC5D;AAAA,EACF,CAAC;AAGD,gBAAc,QAAQ,CAAC,UAAU;AAC/B,UAAM,MAAM,UAAU,KAAK;AAC3B,QAAI,CAAC,IAAK;AAEV,QAAI,CAAC,QAAQ,IAAI,KAAK,GAAG;AACvB,cAAQ,IAAI,OAAO;AAAA,QACjB,MAAM,IAAI;AAAA,QACV,YAAY;AAAA,QACZ,WAAW;AAAA,QACX;AAAA,MAAA,CACD;AAAA,IACH;AAAA,EACF,CAAC;AACH;AAMA,SAAS,yBAAyB,OAAe,eAA8B,WAA+B,SAAmC,WAA8B,aAA2B;AAExM,aAAW,CAAC,MAAM,OAAO,KAAK,cAAc,eAAe,WAAW;AAEpE,QAAI,KAAK,IAAI,KAAK,SAAS,MAAM,MAAM,IAAI,YAAa;AAExD,UAAM,WAAW,6BAA6B,OAAO,MAAM,WAAW;AACtE,QAAI,YAAY,aAAa;AAC3B,cAAQ,OAAO,QAAQ,CAAC,UAAU;AAChC,cAAM,MAAM,UAAU,KAAK;AAC3B,YAAI,CAAC,IAAK;AAEV,cAAM,gBAAgB,QAAQ,IAAI,KAAK;AACvC,YAAI,CAAC,kBAAkB,cAAc,gBAAgB,YAAY,UAAU;AACzE,kBAAQ,IAAI,OAAO;AAAA,YACjB,MAAM,IAAI;AAAA,YACV,YAAY;AAAA,YACZ,WAAW;AAAA,YACX,cAAc;AAAA,YACd,UAAU,UAAU;AAAA,UAAA,CACrB;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF;"}