{"version":3,"file":"levenshtein.js","sources":["../../../src/algorithms/levenshtein.ts"],"sourcesContent":["/**\n * Optimized Levenshtein distance calculation with early termination\n * Performance-focused implementation for fuzzy matching\n * Uses memory pooling to reduce GC pressure by 30-50%\n */\n\nimport { globalArrayPool } from \"../utils/memory-pool.js\";\n\n/**\n * Calculate Levenshtein distance with maximum threshold\n * Returns early if distance exceeds maxDistance for performance\n * \n * @param str1 - First string to compare\n * @param str2 - Second string to compare\n * @param maxDistance - Maximum allowed distance (default: Infinity)\n * @returns Edit distance between strings, or maxDistance + 1 if exceeded\n * \n * @example\n * ```typescript\n * calculateLevenshteinDistance('kitten', 'sitting'); // 3\n * calculateLevenshteinDistance('hello', 'helo', 2); // 1\n * calculateLevenshteinDistance('abc', 'xyz', 1); // 2 (exceeds max)\n * ```\n */\nexport function calculateLevenshteinDistance(\n  //\n  str1: string,\n  str2: string,\n  maxDistance: number = Infinity\n): number {\n  const len1 = str1.length;\n  const len2 = str2.length;\n\n  // Quick checks for performance\n  if (Math.abs(len1 - len2) > maxDistance) {\n    return maxDistance + 1;\n  }\n\n  if (len1 === 0) return len2;\n  if (len2 === 0) return len1;\n  if (str1 === str2) return 0;\n\n  // Use memory pool for arrays to reduce GC pressure\n  const previousRow = globalArrayPool.acquire(len2 + 1) as number[];\n  const currentRow = globalArrayPool.acquire(len2 + 1) as number[];\n\n  try {\n    // Initialize first row\n    for (let j = 0; j <= len2; j++) {\n      previousRow[j] = j;\n    }\n\n    for (let i = 1; i <= len1; i++) {\n      currentRow[0] = i;\n      let minInRow = i;\n\n      for (let j = 1; j <= len2; j++) {\n        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n\n        currentRow[j] = Math.min(\n          currentRow[j - 1] + 1, // insertion\n          previousRow[j] + 1, // deletion\n          previousRow[j - 1] + cost // substitution\n        );\n\n        minInRow = Math.min(minInRow, currentRow[j]);\n      }\n\n      // Early termination if minimum in row exceeds threshold\n      if (minInRow > maxDistance) {\n        return maxDistance + 1;\n      }\n\n      // Copy current to previous for next iteration\n      for (let j = 0; j <= len2; j++) {\n        previousRow[j] = currentRow[j];\n      }\n    }\n\n    return previousRow[len2];\n  } finally {\n    // Always release arrays back to pool\n    globalArrayPool.release(previousRow);\n    globalArrayPool.release(currentRow);\n  }\n}\n\n/**\n * Calculate Damerau-Levenshtein distance (includes transpositions)\n * More expensive but handles character swaps\n */\nexport function calculateDamerauLevenshteinDistance(str1: string, str2: string, maxDistance: number = Infinity): number {\n  const len1 = str1.length;\n  const len2 = str2.length;\n\n  if (Math.abs(len1 - len2) > maxDistance) {\n    return maxDistance + 1;\n  }\n\n  if (len1 === 0) return len2;\n  if (len2 === 0) return len1;\n  if (str1 === str2) return 0;\n\n  const maxLen = Math.max(len1, len2);\n  const H: number[][] = [];\n  const INF = maxLen + 1;\n\n  // Initialize H matrix\n  for (let i = 0; i <= len1 + 1; i++) {\n    H[i] = new Array(len2 + 2).fill(INF);\n  }\n\n  H[0][0] = INF;\n  for (let i = 0; i <= len1; i++) {\n    H[i + 1][0] = INF;\n    H[i + 1][1] = i;\n  }\n  for (let j = 0; j <= len2; j++) {\n    H[0][j + 1] = INF;\n    H[1][j + 1] = j;\n  }\n\n  const charMap = new Map<string, number>();\n\n  for (let i = 1; i <= len1; i++) {\n    let lastMatchCol = 0;\n\n    for (let j = 1; j <= len2; j++) {\n      const char1 = str1[i - 1];\n      const char2 = str2[j - 1];\n      const lastMatchRow = charMap.get(char2) || 0;\n\n      let cost = 1;\n      if (char1 === char2) {\n        cost = 0;\n        lastMatchCol = j;\n      }\n\n      H[i + 1][j + 1] = Math.min(\n        H[i][j] + cost, // substitution\n        H[i + 1][j] + 1, // insertion\n        H[i][j + 1] + 1, // deletion\n        H[lastMatchRow][lastMatchCol] + (i - lastMatchRow - 1) + 1 + (j - lastMatchCol - 1) // transposition\n      );\n    }\n\n    charMap.set(str1[i - 1], i);\n  }\n\n  const result = H[len1 + 1][len2 + 1];\n  return result > maxDistance ? maxDistance + 1 : result;\n}\n\n/**\n * Fast approximate string matching using n-gram similarity\n * Much faster than edit distance for initial filtering\n * Uses memory pooling for Set objects to reduce GC pressure\n * \n * @param str1 - First string to compare\n * @param str2 - Second string to compare\n * @param n - N-gram size (default: 3)\n * @returns Similarity score between 0 and 1\n * \n * @example\n * ```typescript\n * calculateNgramSimilarity('hello', 'hallo'); // ~0.6\n * calculateNgramSimilarity('test', 'test'); // 1.0\n * ```\n */\nexport function calculateNgramSimilarity(str1: string, str2: string, n: number = 3): number {\n  if (str1 === str2) return 1.0;\n  if (str1.length === 0 || str2.length === 0) return 0.0;\n\n  const ngrams1 = generateNgrams(str1, n);\n  const ngrams2 = generateNgrams(str2, n);\n\n  if (ngrams1.length === 0 && ngrams2.length === 0) return 1.0;\n  if (ngrams1.length === 0 || ngrams2.length === 0) return 0.0;\n\n  const set1 = new Set(ngrams1);\n  const set2 = new Set(ngrams2);\n\n  // Calculate intersection size without creating new Set\n  let intersectionSize = 0;\n  for (const item of set1) {\n    if (set2.has(item)) {\n      intersectionSize++;\n    }\n  }\n\n  // Union size = size1 + size2 - intersection\n  const unionSize = set1.size + set2.size - intersectionSize;\n\n  return unionSize > 0 ? intersectionSize / unionSize : 0;\n}\n\n/**\n * Generate n-grams from a string\n * Pre-allocates array for better performance\n * \n * @param str - Input string\n * @param n - N-gram size\n * @returns Array of n-grams\n * \n * @example\n * ```typescript\n * generateNgrams('hello', 3); // ['hel', 'ell', 'llo']\n * generateNgrams('hi', 3); // ['hi']\n * ```\n */\nexport function generateNgrams(str: string, n: number): string[] {\n  if (str.length < n) return [str];\n\n  // Pre-allocate array with exact size needed\n  const count = str.length - n + 1;\n  const ngrams: string[] = new Array(count);\n  \n  for (let i = 0; i < count; i++) {\n    ngrams[i] = str.slice(i, i + n);\n  }\n  \n  return ngrams;\n}\n\n/**\n * Calculate similarity score (0-1) from edit distance\n * \n * @param distance - Edit distance between strings\n * @param maxLength - Maximum length of the two strings\n * @returns Similarity score from 0 to 1 (1 = identical)\n * \n * @example\n * ```typescript\n * distanceToSimilarity(0, 5); // 1.0 (no edits)\n * distanceToSimilarity(2, 10); // 0.8 (2 edits in 10 chars)\n * ```\n */\nexport function distanceToSimilarity(distance: number, maxLength: number): number {\n  if (maxLength === 0) return distance === 0 ? 1.0 : 0.0;\n  return Math.max(0, 1 - distance / maxLength);\n}\n\n/**\n * Check if strings are similar within threshold using fast approximation\n * Uses n-gram pre-filtering before expensive Levenshtein calculation\n * \n * @param str1 - First string to compare\n * @param str2 - Second string to compare\n * @param threshold - Similarity threshold (0-1, default: 0.8)\n * @param maxDistance - Maximum edit distance allowed (default: 2)\n * @returns True if strings are similar enough\n * \n * @example\n * ```typescript\n * areStringsSimilar('hello', 'helo'); // true\n * areStringsSimilar('hello', 'world'); // false\n * ```\n */\nexport function areStringsSimilar(str1: string, str2: string, threshold: number = 0.8, maxDistance: number = 2): boolean {\n  // Quick exact match\n  if (str1 === str2) return true;\n\n  // Quick length check\n  const maxLen = Math.max(str1.length, str2.length);\n  if (Math.abs(str1.length - str2.length) > maxDistance) return false;\n\n  // Use n-gram similarity for fast approximation\n  const ngramSim = calculateNgramSimilarity(str1, str2);\n  if (ngramSim < threshold - 0.2) return false; // Early rejection\n\n  // Calculate actual edit distance only if n-gram similarity is promising\n  const distance = calculateLevenshteinDistance(str1, str2, maxDistance);\n  const similarity = distanceToSimilarity(distance, maxLen);\n\n  return similarity >= threshold;\n}\n"],"names":[],"mappings":"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"}