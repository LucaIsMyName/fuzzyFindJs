{"version":3,"file":"fuzzyfindjs.min.js","sources":["../../src/core/config.ts","../../src/languages/base/LanguageProcessor.ts","../../src/languages/german/GermanProcessor.ts","../../src/languages/english/EnglishProcessor.ts","../../src/languages/spanish/SpanishProcessor.ts","../../src/languages/french/FrenchProcessor.ts","../../src/languages/index.ts","../../src/algorithms/levenshtein.ts","../../src/core/inverted-index.ts","../../src/core/highlighting.ts","../../src/core/cache.ts","../../src/utils/accent-normalization.ts","../../src/core/field-weighting.ts","../../src/utils/stop-words.ts","../../src/utils/word-boundaries.ts","../../src/core/index.ts","../../src/core/serialization.ts","../../src/index.ts"],"sourcesContent":["import type {\n  //\n  FuzzyConfig,\n  FuzzyFeature,\n} from \"./types.js\";\n\n/**\n * Default configuration for FuzzyFindJS\n * Provides sensible defaults that work out of the box\n */\nexport const DEFAULT_CONFIG: FuzzyConfig = {\n  languages: [\"english\"],\n  features: [\"phonetic\", \"compound\", \"synonyms\", \"keyboard-neighbors\", \"partial-words\", \"missing-letters\", \"extra-letters\", \"transpositions\"],\n  performance: \"balanced\",\n  maxResults: 10,\n  minQueryLength: 2,\n  fuzzyThreshold: 0.75,\n  maxEditDistance: 2,\n  ngramSize: 3,\n};\n\n/**\n * Performance-optimized configurations\n */\nexport const PERFORMANCE_CONFIGS: Record<string, Partial<FuzzyConfig>> = {\n  fast: {\n    performance: \"fast\",\n    features: [\"partial-words\", \"missing-letters\"],\n    maxEditDistance: 1,\n    fuzzyThreshold: 0.9,\n    maxResults: 3,\n  },\n  balanced: {\n    performance: \"balanced\",\n    features: [\"phonetic\", \"partial-words\", \"missing-letters\", \"keyboard-neighbors\"],\n    maxEditDistance: 2,\n    fuzzyThreshold: 0.8,\n    maxResults: 5,\n  },\n  comprehensive: {\n    performance: \"comprehensive\",\n    features: [\"phonetic\", \"compound\", \"synonyms\", \"keyboard-neighbors\", \"partial-words\", \"missing-letters\", \"extra-letters\", \"transpositions\"],\n    maxEditDistance: 3,\n    fuzzyThreshold: 0.7,\n    maxResults: 10,\n  },\n};\n\n/**\n * Language-specific feature recommendations\n */\nexport const LANGUAGE_FEATURES: Record<string, FuzzyFeature[]> = {\n  german: [\n    //\n    \"phonetic\",\n    \"compound\",\n    \"synonyms\",\n    \"keyboard-neighbors\",\n    \"partial-words\",\n    \"missing-letters\",\n    \"extra-letters\",\n  ],\n  english: [\n    //\n    \"phonetic\",\n    \"synonyms\",\n    \"keyboard-neighbors\",\n    \"partial-words\",\n    \"missing-letters\",\n    \"transpositions\",\n  ],\n  spanish: [\n    //\n    \"phonetic\",\n    \"synonyms\",\n    \"keyboard-neighbors\",\n    \"partial-words\",\n    \"missing-letters\",\n  ],\n  french: [\n    //\n    \"phonetic\",\n    \"synonyms\",\n    \"keyboard-neighbors\",\n    \"partial-words\",\n    \"missing-letters\",\n  ],\n};\n\n/**\n * Merge user configuration with defaults\n */\nexport function mergeConfig(userConfig: Partial<FuzzyConfig> = {}): FuzzyConfig {\n  const baseConfig = { ...DEFAULT_CONFIG };\n\n  // Apply performance preset if specified\n  if (userConfig.performance && userConfig.performance !== \"balanced\") {\n    const performanceConfig = PERFORMANCE_CONFIGS[userConfig.performance];\n    Object.assign(baseConfig, performanceConfig);\n  }\n\n  // Apply user overrides\n  const mergedConfig = { ...baseConfig, ...userConfig };\n\n  // Auto-adjust features based on languages if not explicitly set\n  if (!userConfig.features && userConfig.languages) {\n    const recommendedFeatures = new Set<FuzzyFeature>();\n\n    for (const lang of userConfig.languages) {\n      const langFeatures = LANGUAGE_FEATURES[lang] || LANGUAGE_FEATURES.english;\n      langFeatures.forEach((feature) => recommendedFeatures.add(feature));\n    }\n\n    mergedConfig.features = Array.from(recommendedFeatures);\n  }\n\n  return mergedConfig;\n}\n\n/**\n * Validate configuration\n */\nexport function validateConfig(config: FuzzyConfig): void {\n  if (config.maxResults < 1) {\n    throw new Error(\"maxResults must be at least 1\");\n  }\n\n  if (config.minQueryLength < 1) {\n    throw new Error(\"minQueryLength must be at least 1\");\n  }\n\n  if (config.fuzzyThreshold < 0 || config.fuzzyThreshold > 1) {\n    throw new Error(\"fuzzyThreshold must be between 0 and 1\");\n  }\n\n  if (config.maxEditDistance < 0) {\n    throw new Error(\"maxEditDistance must be non-negative\");\n  }\n\n  if (config.ngramSize < 2) {\n    throw new Error(\"ngramSize must be at least 2\");\n  }\n\n  if (config.languages.length === 0) {\n    throw new Error(\"At least one language must be specified\");\n  }\n}\n","import type { LanguageProcessor, FuzzyFeature } from \"../../core/types.js\";\n\n/**\n * Abstract base class for language processors\n * Provides common functionality and enforces interface\n */\nexport abstract class BaseLanguageProcessor implements LanguageProcessor {\n  abstract readonly language: string;\n  abstract readonly displayName: string;\n  abstract readonly supportedFeatures: FuzzyFeature[];\n\n  /**\n   * Basic text normalization (override for language-specific behavior)\n   */\n  normalize(text: string): string {\n    return text.toLowerCase().trim().replace(/\\s+/g, \" \");\n  }\n\n  /**\n   * Default phonetic implementation (override for language-specific algorithms)\n   */\n  getPhoneticCode(word: string): string {\n    // Simple soundex-like algorithm as fallback\n    const normalized = this.normalize(word);\n    if (normalized.length === 0) return \"\";\n\n    let code = normalized[0].toUpperCase();\n    const consonantMap: Record<string, string> = {\n      b: \"1\",\n      f: \"1\",\n      p: \"1\",\n      v: \"1\",\n      c: \"2\",\n      g: \"2\",\n      j: \"2\",\n      k: \"2\",\n      q: \"2\",\n      s: \"2\",\n      x: \"2\",\n      z: \"2\",\n      d: \"3\",\n      t: \"3\",\n      l: \"4\",\n      m: \"5\",\n      n: \"5\",\n      r: \"6\",\n    };\n\n    for (let i = 1; i < normalized.length && code.length < 4; i++) {\n      const char = normalized[i];\n      const digit = consonantMap[char];\n      if (digit && digit !== code[code.length - 1]) {\n        code += digit;\n      }\n    }\n\n    return code.padEnd(4, \"0\");\n  }\n\n  /**\n   * Default compound word splitting (override for languages that support it)\n   */\n  splitCompoundWords(word: string): string[] {\n    return [word]; // No splitting by default\n  }\n\n  /**\n   * Generate common word variants\n   */\n  getWordVariants(word: string): string[] {\n    const variants = new Set<string>();\n    const normalized = this.normalize(word);\n\n    variants.add(normalized);\n    variants.add(word); // Original form\n\n    // Add variants without common endings\n    const commonEndings = this.getCommonEndings();\n    for (const ending of commonEndings) {\n      if (normalized.endsWith(ending) && normalized.length > ending.length + 2) {\n        variants.add(normalized.slice(0, -ending.length));\n      }\n    }\n\n    // Add partial variants for longer words\n    if (normalized.length > 4) {\n      for (let i = 3; i < normalized.length; i++) {\n        variants.add(normalized.slice(0, i));\n      }\n    }\n\n    return Array.from(variants);\n  }\n\n  /**\n   * Get common word endings for this language (override for language-specific endings)\n   */\n  protected getCommonEndings(): string[] {\n    return [\n      //\n      \"s\",\n      \"es\",\n      \"ed\",\n      \"ing\",\n      \"er\",\n      \"est\",\n    ];\n  }\n\n  /**\n   * Default synonym lookup (override to provide language-specific synonyms)\n   */\n  getSynonyms(_word: string): string[] {\n    return []; // No built-in synonyms by default\n  }\n\n  /**\n   * Check if two characters are keyboard neighbors\n   */\n  isValidSubstitution(char1: string, char2: string): boolean {\n    const keyboardNeighbors = this.getKeyboardNeighbors();\n    const neighbors = keyboardNeighbors[char1.toLowerCase()];\n    return neighbors ? neighbors.includes(char2.toLowerCase()) : false;\n  }\n\n  /**\n   * Get keyboard neighbor mappings (QWERTY layout by default)\n   */\n  protected getKeyboardNeighbors(): Record<string, string[]> {\n    return {\n      q: [\"w\", \"a\", \"s\"],\n      w: [\"q\", \"e\", \"a\", \"s\", \"d\"],\n      e: [\"w\", \"r\", \"s\", \"d\", \"f\"],\n      r: [\"e\", \"t\", \"d\", \"f\", \"g\"],\n      t: [\"r\", \"y\", \"f\", \"g\", \"h\"],\n      y: [\"t\", \"u\", \"g\", \"h\", \"j\"],\n      u: [\"y\", \"i\", \"h\", \"j\", \"k\"],\n      i: [\"u\", \"o\", \"j\", \"k\", \"l\"],\n      o: [\"i\", \"p\", \"k\", \"l\"],\n      p: [\"o\", \"l\"],\n      a: [\"q\", \"w\", \"s\", \"z\", \"x\"],\n      s: [\"q\", \"w\", \"e\", \"a\", \"d\", \"z\", \"x\", \"c\"],\n      d: [\"w\", \"e\", \"r\", \"s\", \"f\", \"x\", \"c\", \"v\"],\n      f: [\"e\", \"r\", \"t\", \"d\", \"g\", \"c\", \"v\", \"b\"],\n      g: [\"r\", \"t\", \"y\", \"f\", \"h\", \"v\", \"b\", \"n\"],\n      h: [\"t\", \"y\", \"u\", \"g\", \"j\", \"b\", \"n\", \"m\"],\n      j: [\"y\", \"u\", \"i\", \"h\", \"k\", \"n\", \"m\"],\n      k: [\"u\", \"i\", \"o\", \"j\", \"l\", \"m\"],\n      l: [\"i\", \"o\", \"p\", \"k\"],\n      z: [\"a\", \"s\", \"x\"],\n      x: [\"a\", \"s\", \"d\", \"z\", \"c\"],\n      c: [\"s\", \"d\", \"f\", \"x\", \"v\"],\n      v: [\"d\", \"f\", \"g\", \"c\", \"b\"],\n      b: [\"f\", \"g\", \"h\", \"v\", \"n\"],\n      n: [\"g\", \"h\", \"j\", \"b\", \"m\"],\n      m: [\"h\", \"j\", \"k\", \"n\"],\n    };\n  }\n\n  /**\n   * Generate n-grams for partial matching\n   */\n  generateNgrams(word: string, n: number = 3): string[] {\n    const normalized = this.normalize(word);\n    if (normalized.length < n) return [normalized];\n\n    const ngrams: string[] = [];\n    for (let i = 0; i <= normalized.length - n; i++) {\n      ngrams.push(normalized.slice(i, i + n));\n    }\n    return ngrams;\n  }\n\n  /**\n   * Calculate basic edit distance (Levenshtein)\n   */\n  calculateEditDistance(str1: string, str2: string): number {\n    const matrix: number[][] = [];\n    const len1 = str1.length;\n    const len2 = str2.length;\n\n    // Initialize matrix\n    for (let i = 0; i <= len1; i++) {\n      matrix[i] = [i];\n    }\n    for (let j = 0; j <= len2; j++) {\n      matrix[0][j] = j;\n    }\n\n    // Fill matrix\n    for (let i = 1; i <= len1; i++) {\n      for (let j = 1; j <= len2; j++) {\n        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j] + 1, // deletion\n          matrix[i][j - 1] + 1, // insertion\n          matrix[i - 1][j - 1] + cost // substitution\n        );\n      }\n    }\n\n    return matrix[len1][len2];\n  }\n}\n","import { BaseLanguageProcessor } from \"../base/LanguageProcessor.js\";\nimport type { FuzzyFeature } from \"../../core/types.js\";\n\n/**\n * German language processor with specialized features:\n * - Umlaut normalization (ä, ö, ü, ß)\n * - Compound word splitting\n * - German-specific phonetic matching (Kölner Phonetik)\n * - Common German word endings\n */\nexport class GermanProcessor extends BaseLanguageProcessor {\n  readonly language = \"german\";\n  readonly displayName = \"Deutsch\";\n  readonly supportedFeatures: FuzzyFeature[] = [\"phonetic\", \"compound\", \"synonyms\", \"keyboard-neighbors\", \"partial-words\", \"missing-letters\", \"extra-letters\"];\n\n  /**\n   * German text normalization with umlaut handling\n   */\n  normalize(text: string): string {\n    return (\n      text\n        .toLowerCase()\n        .trim()\n        .replace(/\\s+/g, \" \")\n        // Normalize umlauts\n        .replace(/ä/g, \"ae\")\n        .replace(/ö/g, \"oe\")\n        .replace(/ü/g, \"ue\")\n        .replace(/ß/g, \"ss\")\n    );\n  }\n\n  /**\n   * Kölner Phonetik algorithm for German phonetic matching\n   */\n  getPhoneticCode(word: string): string {\n    const normalized = this.normalize(word);\n    if (normalized.length === 0) return \"\";\n\n    let code = \"\";\n    let prev = \"\";\n\n    for (let i = 0; i < normalized.length; i++) {\n      const char = normalized[i];\n      const next = i < normalized.length - 1 ? normalized[i + 1] : \"\";\n      let digit = \"\";\n\n      switch (char) {\n        case \"a\":\n        case \"e\":\n        case \"i\":\n        case \"j\":\n        case \"o\":\n        case \"u\":\n        case \"y\":\n          digit = \"0\";\n          break;\n        case \"h\":\n          // H is ignored\n          continue;\n        case \"b\":\n        case \"p\":\n          digit = \"1\";\n          break;\n        case \"d\":\n        case \"t\":\n          if (next === \"c\" || next === \"s\" || next === \"z\") {\n            digit = \"8\";\n          } else {\n            digit = \"2\";\n          }\n          break;\n        case \"f\":\n        case \"v\":\n        case \"w\":\n          digit = \"3\";\n          break;\n        case \"g\":\n        case \"k\":\n        case \"q\":\n          digit = \"4\";\n          break;\n        case \"c\":\n          if (i === 0) {\n            if (next === \"a\" || next === \"h\" || next === \"k\" || next === \"l\" || next === \"o\" || next === \"q\" || next === \"r\" || next === \"u\" || next === \"x\") {\n              digit = \"4\";\n            } else {\n              digit = \"8\";\n            }\n          } else {\n            if (prev === \"s\" || prev === \"z\") {\n              digit = \"8\";\n            } else if (next === \"h\") {\n              digit = \"4\";\n            } else if (next === \"k\" || next === \"q\") {\n              digit = \"4\";\n            } else {\n              digit = \"8\";\n            }\n          }\n          break;\n        case \"x\":\n          if (prev === \"c\" || prev === \"k\" || prev === \"q\") {\n            digit = \"8\";\n          } else {\n            digit = \"48\";\n          }\n          break;\n        case \"l\":\n          digit = \"5\";\n          break;\n        case \"m\":\n        case \"n\":\n          digit = \"6\";\n          break;\n        case \"r\":\n          digit = \"7\";\n          break;\n        case \"s\":\n        case \"z\":\n          digit = \"8\";\n          break;\n        default:\n          continue;\n      }\n\n      // Don't add consecutive identical digits\n      if (digit && digit !== prev) {\n        code += digit;\n      }\n      prev = digit;\n    }\n\n    return code || \"0\";\n  }\n\n  /**\n   * German compound word splitting\n   * Uses common German compound patterns and a dictionary approach\n   */\n  splitCompoundWords(word: string): string[] {\n    const normalized = this.normalize(word);\n    if (normalized.length < 6) return [word]; // Too short to be compound\n\n    const parts: string[] = [];\n    const commonPrefixes = this.getCommonPrefixes();\n    const commonSuffixes = this.getCommonSuffixes();\n    const commonWords = this.getCommonWords();\n\n    // Try to find known prefixes\n    for (const prefix of commonPrefixes) {\n      if (normalized.startsWith(prefix) && normalized.length > prefix.length + 3) {\n        const remainder = normalized.slice(prefix.length);\n        parts.push(prefix);\n        parts.push(...this.splitCompoundWords(remainder));\n        break;\n      }\n    }\n\n    if (parts.length === 0) {\n      // Try to find known suffixes\n      for (const suffix of commonSuffixes) {\n        if (normalized.endsWith(suffix) && normalized.length > suffix.length + 3) {\n          const remainder = normalized.slice(0, -suffix.length);\n          parts.push(...this.splitCompoundWords(remainder));\n          parts.push(suffix);\n          break;\n        }\n      }\n    }\n\n    if (parts.length === 0) {\n      // Try to find known words within the compound\n      for (let i = 3; i <= normalized.length - 3; i++) {\n        const leftPart = normalized.slice(0, i);\n        const rightPart = normalized.slice(i);\n\n        if (commonWords.has(leftPart) && rightPart.length >= 3) {\n          parts.push(leftPart);\n          parts.push(...this.splitCompoundWords(rightPart));\n          break;\n        }\n      }\n    }\n\n    return parts.length > 0 ? parts : [word];\n  }\n\n  /**\n   * German word variants including common endings\n   */\n  getWordVariants(word: string): string[] {\n    const variants = new Set<string>();\n    const normalized = this.normalize(word);\n\n    variants.add(normalized);\n    variants.add(word);\n\n    // Add compound word parts\n    const compoundParts = this.splitCompoundWords(word);\n    compoundParts.forEach((part) => variants.add(this.normalize(part)));\n\n    // Add variants without German endings\n    const germanEndings = this.getCommonEndings();\n    for (const ending of germanEndings) {\n      if (normalized.endsWith(ending) && normalized.length > ending.length + 2) {\n        variants.add(normalized.slice(0, -ending.length));\n      }\n    }\n\n    // Add partial variants\n    if (normalized.length > 4) {\n      for (let i = 3; i < normalized.length; i++) {\n        variants.add(normalized.slice(0, i));\n      }\n    }\n\n    return Array.from(variants);\n  }\n\n  /**\n   * German word endings\n   */\n  protected getCommonEndings(): string[] {\n    return [\n      //\n      \"en\",\n      \"e\",\n      \"er\",\n      \"n\",\n      \"r\",\n      \"s\",\n      \"es\",\n      \"t\",\n      \"ung\",\n      \"heit\",\n      \"keit\",\n      \"schaft\",\n      \"chen\",\n      \"lein\",\n      \"lich\",\n      \"ig\",\n      \"isch\",\n      \"bar\",\n      \"los\",\n      \"voll\",\n    ];\n  }\n\n  /**\n   * German synonyms for common words\n   */\n  getSynonyms(word: string): string[] {\n    const synonymMap: Record<string, string[]> = {\n      arzt: [\n        //\n        \"doktor\",\n        \"mediziner\",\n        \"doc\",\n      ],\n      krankenhaus: [\n        //\n        \"spital\",\n        \"klinik\",\n        \"hospital\",\n      ],\n      schule: [\n        //\n        \"bildungseinrichtung\",\n        \"lehranstalt\",\n      ],\n      auto: [\n        //\n        \"wagen\",\n        \"fahrzeug\",\n        \"pkw\",\n      ],\n      haus: [\n        //\n        \"gebaeude\",\n        \"heim\",\n        \"wohnhaus\",\n      ],\n      strasse: [\n        //\n        \"weg\",\n        \"gasse\",\n        \"allee\",\n      ],\n      stadt: [\n        //\n        \"ort\",\n        \"gemeinde\",\n        \"ortschaft\",\n      ],\n      arbeit: [\n        //\n        \"job\",\n        \"beruf\",\n        \"taetigkeit\",\n      ],\n      geld: [\n        //\n        \"waehrung\",\n        \"kapital\",\n        \"finanzen\",\n      ],\n      zeit: [\n        //\n        \"dauer\",\n        \"periode\",\n        \"zeitraum\",\n      ],\n    };\n\n    const normalized = this.normalize(word);\n    return synonymMap[normalized] || [];\n  }\n\n  /**\n   * German keyboard layout (QWERTZ)\n   */\n  protected getKeyboardNeighbors(): Record<string, string[]> {\n    return {\n      q: [\n        //\n        \"w\",\n        \"a\",\n        \"s\",\n      ],\n      w: [\n        //\n        \"q\",\n        \"e\",\n        \"a\",\n        \"s\",\n        \"d\",\n      ],\n      e: [\n        //\n        \"w\",\n        \"r\",\n        \"s\",\n        \"d\",\n        \"f\",\n      ],\n      r: [\n        //\n        \"e\",\n        \"t\",\n        \"d\",\n        \"f\",\n        \"g\",\n      ],\n      t: [\n        //\n        \"r\",\n        \"z\",\n        \"f\",\n        \"g\",\n        \"h\",\n      ],\n      z: [\n        //\n        \"t\",\n        \"u\",\n        \"g\",\n        \"h\",\n        \"j\",\n      ], // QWERTZ difference\n      u: [\n        //\n        \"z\",\n        \"i\",\n        \"h\",\n        \"j\",\n        \"k\",\n      ],\n      i: [\n        //\n        \"u\",\n        \"o\",\n        \"j\",\n        \"k\",\n        \"l\",\n      ],\n      o: [\n        //\n        \"i\",\n        \"p\",\n        \"k\",\n        \"l\",\n        \"oe\",\n      ],\n      p: [\n        //\n        \"o\",\n        \"ue\",\n        \"l\",\n        \"oe\",\n      ],\n      ue: [\n        //\n        \"p\",\n        \"ae\",\n      ], // German umlaut\n      a: [\n        //\n        \"q\",\n        \"w\",\n        \"s\",\n        \"y\",\n        \"x\",\n      ],\n      s: [\n        //\n        \"q\",\n        \"w\",\n        \"e\",\n        \"a\",\n        \"d\",\n        \"y\",\n        \"x\",\n        \"c\",\n      ],\n      d: [\n        //\n        \"w\",\n        \"e\",\n        \"r\",\n        \"s\",\n        \"f\",\n        \"x\",\n        \"c\",\n        \"v\",\n      ],\n      f: [\n        //\n        \"e\",\n        \"r\",\n        \"t\",\n        \"d\",\n        \"g\",\n        \"c\",\n        \"v\",\n        \"b\",\n      ],\n      g: [\n        //\n        \"r\",\n        \"t\",\n        \"z\",\n        \"f\",\n        \"h\",\n        \"v\",\n        \"b\",\n        \"n\",\n      ],\n      h: [\n        //\n        \"t\",\n        \"z\",\n        \"u\",\n        \"g\",\n        \"j\",\n        \"b\",\n        \"n\",\n        \"m\",\n      ],\n      j: [\n        //\n        \"z\",\n        \"u\",\n        \"i\",\n        \"h\",\n        \"k\",\n        \"n\",\n        \"m\",\n      ],\n      k: [\n        //\n        \"u\",\n        \"i\",\n        \"o\",\n        \"j\",\n        \"l\",\n        \"m\",\n      ],\n      l: [\n        //\n        \"i\",\n        \"o\",\n        \"p\",\n        \"k\",\n        \"oe\",\n      ],\n      oe: [\n        //\n        \"o\",\n        \"p\",\n        \"ue\",\n        \"l\",\n        \"ae\",\n      ], // German umlaut\n      ae: [\n        //\n        \"ue\",\n        \"oe\",\n      ], // German umlaut\n      y: [\n        //\n        \"a\",\n        \"s\",\n        \"x\",\n      ], // QWERTZ difference\n      x: [\n        //\n        \"a\",\n        \"s\",\n        \"d\",\n        \"y\",\n        \"c\",\n      ],\n      c: [\n        //\n        \"s\",\n        \"d\",\n        \"f\",\n        \"x\",\n        \"v\",\n      ],\n      v: [\n        //\n        \"d\",\n        \"f\",\n        \"g\",\n        \"c\",\n        \"b\",\n      ],\n      b: [\n        //\n        \"f\",\n        \"g\",\n        \"h\",\n        \"v\",\n        \"n\",\n      ],\n      n: [\n        //\n        \"g\",\n        \"h\",\n        \"j\",\n        \"b\",\n        \"m\",\n      ],\n      m: [\n        //\n        \"h\",\n        \"j\",\n        \"k\",\n        \"n\",\n      ],\n    };\n  }\n\n  /**\n   * Common German prefixes for compound word splitting\n   */\n  private getCommonPrefixes(): string[] {\n    return [\"un\", \"vor\", \"nach\", \"bei\", \"mit\", \"ab\", \"an\", \"auf\", \"aus\", \"ein\", \"gegen\", \"hinter\", \"neben\", \"ueber\", \"unter\", \"zwischen\", \"selbst\"];\n  }\n\n  /**\n   * Common German suffixes for compound word splitting\n   */\n  private getCommonSuffixes(): string[] {\n    return [\"haus\", \"platz\", \"strasse\", \"weg\", \"hof\", \"berg\", \"tal\", \"feld\", \"stadt\", \"dorf\", \"heim\", \"werk\", \"bau\", \"anlage\", \"zentrum\"];\n  }\n\n  /**\n   * Common German words for compound splitting\n   */\n  private getCommonWords(): Set<string> {\n    return new Set([\"kranken\", \"kinder\", \"frauen\", \"maenner\", \"alt\", \"neu\", \"gross\", \"klein\", \"hoch\", \"tief\", \"lang\", \"kurz\", \"breit\", \"schmal\", \"dick\", \"duenn\", \"stark\", \"schwach\", \"schnell\", \"langsam\", \"heiss\", \"kalt\", \"warm\", \"auto\", \"bahn\", \"bus\", \"zug\", \"flug\", \"schiff\", \"rad\", \"motor\", \"wasser\", \"feuer\", \"erde\", \"luft\", \"licht\", \"schatten\", \"sonne\", \"mond\", \"tag\", \"nacht\", \"morgen\", \"abend\", \"mittag\", \"zeit\", \"jahr\", \"monat\"]);\n  }\n}\n","import { BaseLanguageProcessor } from \"../base/LanguageProcessor.js\";\nimport type { FuzzyFeature } from \"../../core/types.js\";\n\n/**\n * English language processor with specialized features:\n * - Metaphone phonetic algorithm\n * - Common English contractions\n * - English-specific word endings\n * - Comprehensive synonym support\n */\nexport class EnglishProcessor extends BaseLanguageProcessor {\n  readonly language = \"english\";\n  readonly displayName = \"English\";\n  readonly supportedFeatures: FuzzyFeature[] = [\n    //\n    \"phonetic\",\n    \"synonyms\",\n    \"keyboard-neighbors\",\n    \"partial-words\",\n    \"missing-letters\",\n    \"extra-letters\",\n    \"transpositions\",\n  ];\n\n  /**\n   * English text normalization with contraction handling\n   */\n  normalize(text: string): string {\n    return (\n      text\n        .toLowerCase()\n        .trim()\n        .replace(/\\s+/g, \" \")\n        // Handle common contractions\n        .replace(/won't/g, \"will not\")\n        .replace(/can't/g, \"cannot\")\n        .replace(/n't/g, \" not\")\n        .replace(/'re/g, \" are\")\n        .replace(/'ve/g, \" have\")\n        .replace(/'ll/g, \" will\")\n        .replace(/'d/g, \" would\")\n        .replace(/'m/g, \" am\")\n        .replace(/'/g, \"\")\n    ); // Remove remaining apostrophes\n  }\n\n  /**\n   * Simplified Metaphone algorithm for English phonetic matching\n   */\n  getPhoneticCode(word: string): string {\n    const normalized = this.normalize(word).replace(/[^a-z]/g, \"\");\n    if (normalized.length === 0) return \"\";\n\n    let metaphone = \"\";\n    let current = 0;\n    const length = normalized.length;\n\n    // Handle initial letters\n    if (normalized.startsWith(\"gn\") || normalized.startsWith(\"kn\") || normalized.startsWith(\"pn\") || normalized.startsWith(\"wr\")) {\n      current = 1;\n    }\n\n    while (current < length && metaphone.length < 4) {\n      const char = normalized[current];\n      const next = current + 1 < length ? normalized[current + 1] : \"\";\n      const prev = current > 0 ? normalized[current - 1] : \"\";\n\n      switch (char) {\n        case \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\":\n        case \"u\":\n          if (current === 0) metaphone += char.toUpperCase();\n          break;\n        case \"b\":\n          if (current === length - 1 && prev === \"m\") {\n            // Silent B at end after M\n          } else {\n            metaphone += \"B\";\n          }\n          break;\n        case \"c\":\n          if (next === \"h\") {\n            metaphone += \"X\";\n            current++;\n          } else if (next === \"i\" || next === \"e\" || next === \"y\") {\n            metaphone += \"S\";\n          } else {\n            metaphone += \"K\";\n          }\n          break;\n        case \"d\":\n          if (next === \"g\") {\n            metaphone += \"J\";\n            current++;\n          } else {\n            metaphone += \"T\";\n          }\n          break;\n        case \"f\":\n          metaphone += \"F\";\n          break;\n        case \"g\":\n          if (next === \"h\" && current !== 0) {\n            // Silent GH\n          } else if (next === \"n\") {\n            metaphone += \"N\";\n            current++;\n          } else if (next === \"i\" || next === \"e\" || next === \"y\") {\n            metaphone += \"J\";\n          } else {\n            metaphone += \"K\";\n          }\n          break;\n        case \"h\":\n          if (current === 0 || \"aeiou\".includes(prev) || \"aeiou\".includes(next)) {\n            metaphone += \"H\";\n          }\n          break;\n        case \"j\":\n          metaphone += \"J\";\n          break;\n        case \"k\":\n          if (prev !== \"c\") {\n            metaphone += \"K\";\n          }\n          break;\n        case \"l\":\n          metaphone += \"L\";\n          break;\n        case \"m\":\n          metaphone += \"M\";\n          break;\n        case \"n\":\n          metaphone += \"N\";\n          break;\n        case \"p\":\n          if (next === \"h\") {\n            metaphone += \"F\";\n            current++;\n          } else {\n            metaphone += \"P\";\n          }\n          break;\n        case \"q\":\n          metaphone += \"K\";\n          break;\n        case \"r\":\n          metaphone += \"R\";\n          break;\n        case \"s\":\n          if (next === \"h\") {\n            metaphone += \"X\";\n            current++;\n          } else {\n            metaphone += \"S\";\n          }\n          break;\n        case \"t\":\n          if (next === \"h\") {\n            metaphone += \"0\";\n            current++;\n          } else if (next === \"i\" && current + 2 < length && (normalized[current + 2] === \"a\" || normalized[current + 2] === \"o\")) {\n            metaphone += \"X\";\n          } else {\n            metaphone += \"T\";\n          }\n          break;\n        case \"v\":\n          metaphone += \"F\";\n          break;\n        case \"w\":\n          if (\"aeiou\".includes(next)) {\n            metaphone += \"W\";\n          }\n          break;\n        case \"x\":\n          metaphone += \"KS\";\n          break;\n        case \"y\":\n          if (\"aeiou\".includes(next)) {\n            metaphone += \"Y\";\n          }\n          break;\n        case \"z\":\n          metaphone += \"S\";\n          break;\n      }\n      current++;\n    }\n\n    return metaphone || \"A\";\n  }\n\n  /**\n   * English word variants\n   */\n  getWordVariants(word: string): string[] {\n    const variants = new Set<string>();\n    const normalized = this.normalize(word);\n\n    variants.add(normalized);\n    variants.add(word);\n\n    // Add variants without English endings\n    const englishEndings = this.getCommonEndings();\n    for (const ending of englishEndings) {\n      if (normalized.endsWith(ending) && normalized.length > ending.length + 2) {\n        variants.add(normalized.slice(0, -ending.length));\n      }\n    }\n\n    // Add plural/singular variants\n    if (normalized.endsWith(\"s\") && normalized.length > 3) {\n      variants.add(normalized.slice(0, -1));\n    }\n    if (!normalized.endsWith(\"s\")) {\n      variants.add(normalized + \"s\");\n    }\n\n    // Add -ing/-ed variants\n    if (normalized.endsWith(\"ing\") && normalized.length > 5) {\n      const base = normalized.slice(0, -3);\n      variants.add(base);\n      variants.add(base + \"e\"); // handle dropped 'e'\n    }\n    if (normalized.endsWith(\"ed\") && normalized.length > 4) {\n      const base = normalized.slice(0, -2);\n      variants.add(base);\n      variants.add(base + \"e\"); // handle dropped 'e'\n    }\n\n    // Add partial variants\n    if (normalized.length > 4) {\n      for (let i = 3; i < normalized.length; i++) {\n        variants.add(normalized.slice(0, i));\n      }\n    }\n\n    return Array.from(variants);\n  }\n\n  /**\n   * English word endings\n   */\n  protected getCommonEndings(): string[] {\n    return [\n      //\n      \"s\",\n      \"es\",\n      \"ed\",\n      \"ing\",\n      \"er\",\n      \"est\",\n      \"ly\",\n      \"tion\",\n      \"sion\",\n      \"ness\",\n      \"ment\",\n      \"able\",\n      \"ible\",\n      \"ful\",\n      \"less\",\n      \"ous\",\n      \"ious\",\n      \"al\",\n      \"ial\",\n      \"ic\",\n      \"ive\",\n      \"ary\",\n      \"ery\",\n      \"ory\",\n    ];\n  }\n\n  /**\n   * English synonyms for common words\n   */\n  getSynonyms(word: string): string[] {\n    const synonymMap: Record<string, string[]> = {\n      doctor: [\n        //\n        \"physician\",\n        \"medic\",\n        \"doc\",\n        \"md\",\n      ],\n      hospital: [\n        //\n        \"clinic\",\n        \"medical center\",\n        \"infirmary\",\n      ],\n      school: [\n        //\n        \"academy\",\n        \"institution\",\n        \"college\",\n        \"university\",\n      ],\n      car: [\n        //\n        \"vehicle\",\n        \"automobile\",\n        \"auto\",\n      ],\n      house: [\n        //\n        \"home\",\n        \"residence\",\n        \"dwelling\",\n        \"building\",\n      ],\n      street: [\n        //\n        \"road\",\n        \"avenue\",\n        \"lane\",\n        \"boulevard\",\n      ],\n      city: [\n        //\n        \"town\",\n        \"municipality\",\n        \"urban area\",\n      ],\n      work: [\n        //\n        \"job\",\n        \"employment\",\n        \"occupation\",\n        \"career\",\n      ],\n      money: [\n        //\n        \"cash\",\n        \"currency\",\n        \"funds\",\n        \"capital\",\n      ],\n      time: [\n        //\n        \"duration\",\n        \"period\",\n        \"moment\",\n        \"hour\",\n      ],\n      big: [\n        //\n        \"large\",\n        \"huge\",\n        \"enormous\",\n        \"massive\",\n        \"giant\",\n      ],\n      small: [\n        //\n        \"little\",\n        \"tiny\",\n        \"miniature\",\n        \"petite\",\n      ],\n      fast: [\n        //\n        \"quick\",\n        \"rapid\",\n        \"speedy\",\n        \"swift\",\n      ],\n      slow: [\n        //\n        \"sluggish\",\n        \"gradual\",\n        \"leisurely\",\n      ],\n      good: [\n        //\n        \"excellent\",\n        \"great\",\n        \"wonderful\",\n        \"fine\",\n      ],\n      bad: [\n        //\n        \"poor\",\n        \"terrible\",\n        \"awful\",\n        \"horrible\",\n      ],\n      happy: [\n        //\n        \"joyful\",\n        \"cheerful\",\n        \"glad\",\n        \"pleased\",\n      ],\n      sad: [\n        //\n        \"unhappy\",\n        \"depressed\",\n        \"melancholy\",\n        \"sorrowful\",\n      ],\n    };\n\n    const normalized = this.normalize(word);\n    return synonymMap[normalized] || [];\n  }\n}\n","import { BaseLanguageProcessor } from \"../base/LanguageProcessor.js\";\nimport type { FuzzyFeature } from \"../../core/types.js\";\n\n/**\n * Spanish language processor with specialized features:\n * - Accent normalization (á, é, í, ó, ú, ñ)\n * - Spanish phonetic patterns\n * - Common Spanish word endings\n * - Spanish synonym support\n */\nexport class SpanishProcessor extends BaseLanguageProcessor {\n  readonly language = \"spanish\";\n  readonly displayName = \"Español\";\n  readonly supportedFeatures: FuzzyFeature[] = [\n    //\n    \"phonetic\",\n    \"synonyms\",\n    \"keyboard-neighbors\",\n    \"partial-words\",\n    \"missing-letters\",\n    \"extra-letters\",\n  ];\n\n  /**\n   * Spanish text normalization with accent handling\n   */\n  normalize(text: string): string {\n    return (\n      text\n        .toLowerCase()\n        .trim()\n        .replace(/\\s+/g, \" \")\n        // Normalize accented characters\n        .replace(/á/g, \"a\")\n        .replace(/é/g, \"e\")\n        .replace(/í/g, \"i\")\n        .replace(/ó/g, \"o\")\n        .replace(/ú/g, \"u\")\n        .replace(/ñ/g, \"n\")\n        .replace(/ü/g, \"u\")\n    );\n  }\n\n  /**\n   * Spanish phonetic matching\n   */\n  getPhoneticCode(word: string): string {\n    const normalized = this.normalize(word);\n    if (normalized.length === 0) return \"\";\n\n    let code = \"\";\n    let prev = \"\";\n\n    for (let i = 0; i < normalized.length; i++) {\n      const char = normalized[i];\n      const next = i < normalized.length - 1 ? normalized[i + 1] : \"\";\n      let digit = \"\";\n\n      switch (char) {\n        case \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\":\n        case \"u\":\n          digit = \"0\";\n          break;\n        case \"b\":\n        case \"v\": // B and V sound similar in Spanish\n          digit = \"1\";\n          break;\n        case \"c\":\n          if (next === \"h\") {\n            digit = \"2\"; // CH sound\n          } else if (next === \"e\" || next === \"i\") {\n            digit = \"8\"; // CE, CI sounds like S\n          } else {\n            digit = \"4\";\n          }\n          break;\n        case \"d\":\n          digit = \"3\";\n          break;\n        case \"f\":\n          digit = \"5\";\n          break;\n        case \"g\":\n          if (next === \"u\" && i + 2 < normalized.length && (normalized[i + 2] === \"e\" || normalized[i + 2] === \"i\")) {\n            digit = \"4\"; // GUE, GUI\n          } else if (next === \"e\" || next === \"i\") {\n            digit = \"6\"; // GE, GI sound like J\n          } else {\n            digit = \"4\";\n          }\n          break;\n        case \"h\":\n          // H is silent in Spanish\n          continue;\n        case \"j\":\n          digit = \"6\";\n          break;\n        case \"k\":\n          digit = \"4\";\n          break;\n        case \"l\":\n          if (next === \"l\") {\n            digit = \"7\"; // LL sound\n          } else {\n            digit = \"5\";\n          }\n          break;\n        case \"m\":\n          digit = \"6\";\n          break;\n        case \"n\":\n          if (next === \"n\") {\n            digit = \"7\"; // NN sound (rare)\n          } else {\n            digit = \"6\";\n          }\n          break;\n        case \"ñ\":\n          digit = \"7\"; // Ñ sound\n          break;\n        case \"p\":\n          digit = \"1\";\n          break;\n        case \"q\":\n          digit = \"4\";\n          break;\n        case \"r\":\n          if (next === \"r\" || i === 0) {\n            digit = \"8\"; // RR or initial R\n          } else {\n            digit = \"7\";\n          }\n          break;\n        case \"s\":\n          digit = \"8\";\n          break;\n        case \"t\":\n          digit = \"3\";\n          break;\n        case \"w\":\n          digit = \"1\"; // Rare in Spanish\n          break;\n        case \"x\":\n          digit = \"48\";\n          break;\n        case \"y\":\n          digit = \"7\";\n          break;\n        case \"z\":\n          digit = \"8\";\n          break;\n        default:\n          continue;\n      }\n\n      if (digit && digit !== prev) {\n        code += digit;\n      }\n      prev = digit;\n    }\n\n    return code || \"0\";\n  }\n\n  /**\n   * Spanish word endings\n   */\n  protected getCommonEndings(): string[] {\n    return [\n      //\n      \"o\",\n      \"a\",\n      \"os\",\n      \"as\",\n      \"e\",\n      \"es\",\n      \"ar\",\n      \"er\",\n      \"ir\",\n      \"ado\",\n      \"ada\",\n      \"idos\",\n      \"idas\",\n      \"ando\",\n      \"endo\",\n      \"iendo\",\n      \"cion\",\n      \"sion\",\n      \"dad\",\n      \"tad\",\n      \"mente\",\n      \"oso\",\n      \"osa\",\n      \"ito\",\n      \"ita\",\n      \"illo\",\n      \"illa\",\n    ];\n  }\n\n  /**\n   * Spanish synonyms\n   */\n  getSynonyms(word: string): string[] {\n    const synonymMap: Record<string, string[]> = {\n      medico: [\n        //\n        \"doctor\",\n        \"facultativo\",\n      ],\n      hospital: [\n        //\n        \"clinica\",\n        \"sanatorio\",\n      ],\n      escuela: [\n        //\n        \"colegio\",\n        \"instituto\",\n      ],\n      coche: [\n        //\n        \"auto\",\n        \"automovil\",\n        \"vehiculo\",\n      ],\n      casa: [\n        //\n        \"hogar\",\n        \"vivienda\",\n        \"domicilio\",\n      ],\n      calle: [\n        //\n        \"via\",\n        \"avenida\",\n        \"carretera\",\n      ],\n      ciudad: [\n        //\n        \"urbe\",\n        \"poblacion\",\n        \"municipio\",\n      ],\n      trabajo: [\n        //\n        \"empleo\",\n        \"ocupacion\",\n        \"labor\",\n      ],\n      dinero: [\n        //\n        \"plata\",\n        \"efectivo\",\n        \"capital\",\n      ],\n      tiempo: [\n        //\n        \"momento\",\n        \"periodo\",\n        \"duracion\",\n      ],\n      grande: [\n        //\n        \"enorme\",\n        \"gigante\",\n        \"inmenso\",\n      ],\n      pequeno: [\n        //\n        \"chico\",\n        \"diminuto\",\n        \"minusculo\",\n      ],\n      rapido: [\n        //\n        \"veloz\",\n        \"ligero\",\n        \"acelerado\",\n      ],\n      lento: [\n        //\n        \"despacio\",\n        \"pausado\",\n      ],\n      bueno: [\n        //\n        \"excelente\",\n        \"magnifico\",\n        \"estupendo\",\n      ],\n      malo: [\n        //\n        \"pesimo\",\n        \"terrible\",\n        \"horrible\",\n      ],\n    };\n\n    const normalized = this.normalize(word);\n    return synonymMap[normalized] || [];\n  }\n}\n","import { BaseLanguageProcessor } from \"../base/LanguageProcessor.js\";\nimport type { FuzzyFeature } from \"../../core/types.js\";\n\n/**\n * French language processor with specialized features:\n * - Accent normalization (à, é, è, ê, ç, etc.)\n * - French phonetic patterns\n * - Common French word endings\n * - French synonym support\n */\nexport class FrenchProcessor extends BaseLanguageProcessor {\n  readonly language = \"french\";\n  readonly displayName = \"Français\";\n  readonly supportedFeatures: FuzzyFeature[] = [\n    //\n    \"phonetic\",\n    \"synonyms\",\n    \"keyboard-neighbors\",\n    \"partial-words\",\n    \"missing-letters\",\n    \"extra-letters\",\n  ];\n\n  /**\n   * French text normalization with accent handling\n   */\n  normalize(text: string): string {\n    return (\n      text\n        .toLowerCase()\n        .trim()\n        .replace(/\\s+/g, \" \")\n        // Normalize accented characters\n        .replace(/[àáâãä]/g, \"a\")\n        .replace(/[èéêë]/g, \"e\")\n        .replace(/[ìíîï]/g, \"i\")\n        .replace(/[òóôõö]/g, \"o\")\n        .replace(/[ùúûü]/g, \"u\")\n        .replace(/ç/g, \"c\")\n        .replace(/ñ/g, \"n\")\n        .replace(/ÿ/g, \"y\")\n    );\n  }\n\n  /**\n   * French phonetic matching\n   */\n  getPhoneticCode(word: string): string {\n    const normalized = this.normalize(word);\n    if (normalized.length === 0) return \"\";\n\n    let code = \"\";\n    let prev = \"\";\n\n    for (let i = 0; i < normalized.length; i++) {\n      const char = normalized[i];\n      const next = i < normalized.length - 1 ? normalized[i + 1] : \"\";\n      const next2 = i < normalized.length - 2 ? normalized[i + 2] : \"\";\n      let digit = \"\";\n\n      switch (char) {\n        case \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\":\n        case \"u\":\n        case \"y\":\n          digit = \"0\";\n          break;\n        case \"b\":\n          digit = \"1\";\n          break;\n        case \"c\":\n          if (next === \"h\") {\n            digit = \"2\"; // CH sound\n          } else if (next === \"e\" || next === \"i\") {\n            digit = \"8\"; // CE, CI sounds like S\n          } else {\n            digit = \"4\";\n          }\n          break;\n        case \"d\":\n          digit = \"3\";\n          break;\n        case \"f\":\n          digit = \"5\";\n          break;\n        case \"g\":\n          if (next === \"n\") {\n            digit = \"6\"; // GN sound\n          } else if (next === \"u\" && (next2 === \"e\" || next2 === \"i\")) {\n            digit = \"4\"; // GUE, GUI\n          } else if (next === \"e\" || next === \"i\") {\n            digit = \"6\"; // GE, GI sound like J\n          } else {\n            digit = \"4\";\n          }\n          break;\n        case \"h\":\n          // H is often silent in French\n          if (i === 0) {\n            digit = \"0\"; // Initial H\n          }\n          break;\n        case \"j\":\n          digit = \"6\";\n          break;\n        case \"k\":\n          digit = \"4\";\n          break;\n        case \"l\":\n          digit = \"5\";\n          break;\n        case \"m\":\n          digit = \"6\";\n          break;\n        case \"n\":\n          digit = \"6\";\n          break;\n        case \"p\":\n          if (next === \"h\") {\n            digit = \"5\"; // PH sounds like F\n          } else {\n            digit = \"1\";\n          }\n          break;\n        case \"q\":\n          digit = \"4\";\n          break;\n        case \"r\":\n          digit = \"7\";\n          break;\n        case \"s\":\n          digit = \"8\";\n          break;\n        case \"t\":\n          if (next === \"h\") {\n            digit = \"3\"; // TH sound\n          } else {\n            digit = \"3\";\n          }\n          break;\n        case \"v\":\n          digit = \"5\";\n          break;\n        case \"w\":\n          digit = \"5\"; // Rare in French\n          break;\n        case \"x\":\n          digit = \"48\";\n          break;\n        case \"z\":\n          digit = \"8\";\n          break;\n        default:\n          continue;\n      }\n\n      if (digit && digit !== prev) {\n        code += digit;\n      }\n      prev = digit;\n    }\n\n    return code || \"0\";\n  }\n\n  /**\n   * French word endings\n   */\n  protected getCommonEndings(): string[] {\n    return [\"e\", \"es\", \"s\", \"x\", \"ent\", \"ant\", \"ment\", \"tion\", \"sion\", \"eur\", \"euse\", \"teur\", \"trice\", \"able\", \"ible\", \"ique\", \"aire\", \"oire\", \"ette\", \"elle\", \"esse\", \"asse\", \"isse\", \"age\", \"isme\", \"iste\", \"ite\", \"ude\", \"ade\"];\n  }\n\n  /**\n   * French synonyms\n   */\n  getSynonyms(word: string): string[] {\n    const synonymMap: Record<string, string[]> = {\n      medecin: [\n        //\n        \"docteur\",\n        \"praticien\",\n      ],\n      hopital: [\n        //\n        \"clinique\",\n        \"centre medical\",\n      ],\n      ecole: [\n        //\n        \"etablissement\",\n        \"institution\",\n      ],\n      voiture: [\n        //\n        \"automobile\",\n        \"vehicule\",\n        \"auto\",\n      ],\n      maison: [\n        //\n        \"domicile\",\n        \"residence\",\n        \"habitation\",\n      ],\n      rue: [\n        //\n        \"avenue\",\n        \"boulevard\",\n        \"voie\",\n      ],\n      ville: [\n        //\n        \"cite\",\n        \"commune\",\n        \"agglomeration\",\n      ],\n      travail: [\n        //\n        \"emploi\",\n        \"occupation\",\n        \"metier\",\n      ],\n      argent: [\n        //\n        \"monnaie\",\n        \"especes\",\n        \"capital\",\n      ],\n      temps: [\n        //\n        \"duree\",\n        \"periode\",\n        \"moment\",\n      ],\n      grand: [\n        //\n        \"enorme\",\n        \"immense\",\n        \"gigantesque\",\n      ],\n      petit: [\n        //\n        \"minuscule\",\n        \"minime\",\n        \"reduit\",\n      ],\n      rapide: [\n        //\n        \"vite\",\n        \"accelere\",\n        \"prompt\",\n      ],\n      lent: [\n        //\n        \"lentement\",\n        \"doucement\",\n      ],\n      bon: [\n        //\n        \"excellent\",\n        \"parfait\",\n        \"formidable\",\n      ],\n      mauvais: [\n        //\n        \"terrible\",\n        \"affreux\",\n        \"horrible\",\n      ],\n      heureux: [\n        //\n        \"joyeux\",\n        \"content\",\n        \"ravi\",\n      ],\n      triste: [\n        //\n        \"malheureux\",\n        \"chagrine\",\n        \"melancolique\",\n      ],\n    };\n\n    const normalized = this.normalize(word);\n    return synonymMap[normalized] || [];\n  }\n\n  /**\n   * French keyboard layout (AZERTY)\n   */\n  protected getKeyboardNeighbors(): Record<string, string[]> {\n    return {\n      a: [\n        //\n        \"z\",\n        \"e\",\n        \"r\",\n        \"q\",\n        \"s\",\n      ],\n      z: [\n        //\n        \"a\",\n        \"e\",\n        \"r\",\n        \"q\",\n        \"s\",\n        \"d\",\n      ],\n      e: [\n        //\n        \"z\",\n        \"r\",\n        \"t\",\n        \"s\",\n        \"d\",\n        \"f\",\n      ],\n      r: [\n        //\n        \"e\",\n        \"t\",\n        \"y\",\n        \"d\",\n        \"f\",\n        \"g\",\n      ],\n      t: [\n        //\n        \"r\",\n        \"y\",\n        \"u\",\n        \"f\",\n        \"g\",\n        \"h\",\n      ],\n      y: [\n        //\n        \"t\",\n        \"u\",\n        \"i\",\n        \"g\",\n        \"h\",\n        \"j\",\n      ],\n      u: [\n        //\n        \"y\",\n        \"i\",\n        \"o\",\n        \"h\",\n        \"j\",\n        \"k\",\n      ],\n      i: [\n        //\n        \"u\",\n        \"o\",\n        \"p\",\n        \"j\",\n        \"k\",\n        \"l\",\n      ],\n      o: [\n        //\n        \"i\",\n        \"p\",\n        \"k\",\n        \"l\",\n        \"m\",\n      ],\n      p: [\n        //\n        \"o\",\n        \"l\",\n        \"m\",\n      ],\n      q: [\n        //\n        \"a\",\n        \"z\",\n        \"s\",\n        \"w\",\n        \"x\",\n      ],\n      s: [\n        //\n        \"a\",\n        \"z\",\n        \"e\",\n        \"q\",\n        \"d\",\n        \"w\",\n        \"x\",\n        \"c\",\n      ],\n      d: [\n        //\n        \"z\",\n        \"e\",\n        \"r\",\n        \"s\",\n        \"f\",\n        \"x\",\n        \"c\",\n        \"v\",\n      ],\n      f: [\n        //\n        \"e\",\n        \"r\",\n        \"t\",\n        \"d\",\n        \"g\",\n        \"c\",\n        \"v\",\n        \"b\",\n      ],\n      g: [\n        //\n        \"r\",\n        \"t\",\n        \"y\",\n        \"f\",\n        \"h\",\n        \"v\",\n        \"b\",\n        \"n\",\n      ],\n      h: [\n        //\n        \"t\",\n        \"y\",\n        \"u\",\n        \"g\",\n        \"j\",\n        \"b\",\n        \"n\",\n      ],\n      j: [\n        //\n        \"y\",\n        \"u\",\n        \"i\",\n        \"h\",\n        \"k\",\n        \"n\",\n      ],\n      k: [\n        //\n        \"u\",\n        \"i\",\n        \"o\",\n        \"j\",\n        \"l\",\n      ],\n      l: [\n        //\n        \"i\",\n        \"o\",\n        \"p\",\n        \"k\",\n        \"m\",\n      ],\n      m: [\n        //\n        \"o\",\n        \"p\",\n        \"l\",\n      ],\n      w: [\n        //\n        \"q\",\n        \"s\",\n        \"x\",\n      ],\n      x: [\n        //\n        \"q\",\n        \"s\",\n        \"d\",\n        \"w\",\n        \"c\",\n      ],\n      c: [\n        //\n        \"s\",\n        \"d\",\n        \"f\",\n        \"x\",\n        \"v\",\n      ],\n      v: [\n        //\n        \"d\",\n        \"f\",\n        \"g\",\n        \"c\",\n        \"b\",\n      ],\n      b: [\n        //\n        \"f\",\n        \"g\",\n        \"h\",\n        \"v\",\n        \"n\",\n      ],\n      n: [\n        //\n        \"g\",\n        \"h\",\n        \"j\",\n        \"b\",\n      ],\n    };\n  }\n}\n","import type { LanguageProcessor } from \"../core/types.js\";\nimport { GermanProcessor } from \"./german/GermanProcessor.js\";\nimport { EnglishProcessor } from \"./english/EnglishProcessor.js\";\nimport { SpanishProcessor } from \"./spanish/SpanishProcessor.js\";\nimport { FrenchProcessor } from \"./french/FrenchProcessor.js\";\n\n/**\n * Registry of all available language processors\n */\nexport class LanguageRegistry {\n  private static processors = new Map<string, LanguageProcessor>([\n    [\"german\", new GermanProcessor()],\n    [\"english\", new EnglishProcessor()],\n    [\"spanish\", new SpanishProcessor()],\n    [\"french\", new FrenchProcessor()],\n  ]);\n\n  /**\n   * Get a language processor by name\n   */\n  static getProcessor(language: string): LanguageProcessor | undefined {\n    return this.processors.get(language.toLowerCase());\n  }\n\n  /**\n   * Get multiple language processors\n   */\n  static getProcessors(languages: string[]): LanguageProcessor[] {\n    return languages.map((lang) => this.getProcessor(lang)).filter((processor): processor is LanguageProcessor => processor !== undefined);\n  }\n\n  /**\n   * Get all available language names\n   */\n  static getAvailableLanguages(): string[] {\n    return Array.from(this.processors.keys());\n  }\n\n  /**\n   * Register a custom language processor\n   */\n  static registerProcessor(processor: LanguageProcessor): void {\n    this.processors.set(processor.language.toLowerCase(), processor);\n  }\n\n  /**\n   * Check if a language is supported\n   */\n  static isSupported(language: string): boolean {\n    return this.processors.has(language.toLowerCase());\n  }\n\n  /**\n   * Get processor info for all languages\n   */\n  static getProcessorInfo(): Array<{\n    language: string;\n    displayName: string;\n    supportedFeatures: string[];\n  }> {\n    return Array.from(this.processors.values()).map((processor) => ({\n      language: processor.language,\n      displayName: processor.displayName,\n      supportedFeatures: processor.supportedFeatures,\n    }));\n  }\n}\n\n// Export individual processors for direct use\nexport { GermanProcessor } from \"./german/GermanProcessor.js\";\nexport { EnglishProcessor } from \"./english/EnglishProcessor.js\";\nexport { SpanishProcessor } from \"./spanish/SpanishProcessor.js\";\nexport { FrenchProcessor } from \"./french/FrenchProcessor.js\";\nexport { BaseLanguageProcessor } from \"./base/LanguageProcessor.js\";\n","/**\n * Optimized Levenshtein distance calculation with early termination\n * Performance-focused implementation for fuzzy matching\n */\n\n/**\n * Calculate Levenshtein distance with maximum threshold\n * Returns early if distance exceeds maxDistance for performance\n */\nexport function calculateLevenshteinDistance(str1: string, str2: string, maxDistance: number = Infinity): number {\n  const len1 = str1.length;\n  const len2 = str2.length;\n\n  // Quick checks for performance\n  if (Math.abs(len1 - len2) > maxDistance) {\n    return maxDistance + 1;\n  }\n\n  if (len1 === 0) return len2;\n  if (len2 === 0) return len1;\n  if (str1 === str2) return 0;\n\n  // Use single array optimization for memory efficiency\n  let previousRow = new Array(len2 + 1);\n  let currentRow = new Array(len2 + 1);\n\n  // Initialize first row\n  for (let j = 0; j <= len2; j++) {\n    previousRow[j] = j;\n  }\n\n  for (let i = 1; i <= len1; i++) {\n    currentRow[0] = i;\n    let minInRow = i;\n\n    for (let j = 1; j <= len2; j++) {\n      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n\n      currentRow[j] = Math.min(\n        currentRow[j - 1] + 1, // insertion\n        previousRow[j] + 1, // deletion\n        previousRow[j - 1] + cost // substitution\n      );\n\n      minInRow = Math.min(minInRow, currentRow[j]);\n    }\n\n    // Early termination if minimum in row exceeds threshold\n    if (minInRow > maxDistance) {\n      return maxDistance + 1;\n    }\n\n    // Swap arrays\n    [previousRow, currentRow] = [currentRow, previousRow];\n  }\n\n  return previousRow[len2];\n}\n\n/**\n * Calculate Damerau-Levenshtein distance (includes transpositions)\n * More expensive but handles character swaps\n */\nexport function calculateDamerauLevenshteinDistance(str1: string, str2: string, maxDistance: number = Infinity): number {\n  const len1 = str1.length;\n  const len2 = str2.length;\n\n  if (Math.abs(len1 - len2) > maxDistance) {\n    return maxDistance + 1;\n  }\n\n  if (len1 === 0) return len2;\n  if (len2 === 0) return len1;\n  if (str1 === str2) return 0;\n\n  const maxLen = Math.max(len1, len2);\n  const H: number[][] = [];\n  const INF = maxLen + 1;\n\n  // Initialize H matrix\n  for (let i = 0; i <= len1 + 1; i++) {\n    H[i] = new Array(len2 + 2).fill(INF);\n  }\n\n  H[0][0] = INF;\n  for (let i = 0; i <= len1; i++) {\n    H[i + 1][0] = INF;\n    H[i + 1][1] = i;\n  }\n  for (let j = 0; j <= len2; j++) {\n    H[0][j + 1] = INF;\n    H[1][j + 1] = j;\n  }\n\n  const charMap = new Map<string, number>();\n\n  for (let i = 1; i <= len1; i++) {\n    let lastMatchCol = 0;\n\n    for (let j = 1; j <= len2; j++) {\n      const char1 = str1[i - 1];\n      const char2 = str2[j - 1];\n      const lastMatchRow = charMap.get(char2) || 0;\n\n      let cost = 1;\n      if (char1 === char2) {\n        cost = 0;\n        lastMatchCol = j;\n      }\n\n      H[i + 1][j + 1] = Math.min(\n        H[i][j] + cost, // substitution\n        H[i + 1][j] + 1, // insertion\n        H[i][j + 1] + 1, // deletion\n        H[lastMatchRow][lastMatchCol] + (i - lastMatchRow - 1) + 1 + (j - lastMatchCol - 1) // transposition\n      );\n    }\n\n    charMap.set(str1[i - 1], i);\n  }\n\n  const result = H[len1 + 1][len2 + 1];\n  return result > maxDistance ? maxDistance + 1 : result;\n}\n\n/**\n * Fast approximate string matching using n-gram similarity\n * Much faster than edit distance for initial filtering\n */\nexport function calculateNgramSimilarity(str1: string, str2: string, n: number = 3): number {\n  if (str1 === str2) return 1.0;\n  if (str1.length === 0 || str2.length === 0) return 0.0;\n\n  const ngrams1 = generateNgrams(str1, n);\n  const ngrams2 = generateNgrams(str2, n);\n\n  if (ngrams1.length === 0 && ngrams2.length === 0) return 1.0;\n  if (ngrams1.length === 0 || ngrams2.length === 0) return 0.0;\n\n  const set1 = new Set(ngrams1);\n  const set2 = new Set(ngrams2);\n\n  const intersection = new Set([...set1].filter((x) => set2.has(x)));\n  const union = new Set([...set1, ...set2]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Generate n-grams from a string\n */\nfunction generateNgrams(str: string, n: number): string[] {\n  if (str.length < n) return [str];\n\n  const ngrams: string[] = [];\n  for (let i = 0; i <= str.length - n; i++) {\n    ngrams.push(str.slice(i, i + n));\n  }\n  return ngrams;\n}\n\n/**\n * Calculate similarity score (0-1) from edit distance\n */\nexport function distanceToSimilarity(distance: number, maxLength: number): number {\n  if (maxLength === 0) return distance === 0 ? 1.0 : 0.0;\n  return Math.max(0, 1 - distance / maxLength);\n}\n\n/**\n * Check if strings are similar within threshold using fast approximation\n */\nexport function areStringsSimilar(str1: string, str2: string, threshold: number = 0.8, maxDistance: number = 2): boolean {\n  // Quick exact match\n  if (str1 === str2) return true;\n\n  // Quick length check\n  const maxLen = Math.max(str1.length, str2.length);\n  if (Math.abs(str1.length - str2.length) > maxDistance) return false;\n\n  // Use n-gram similarity for fast approximation\n  const ngramSim = calculateNgramSimilarity(str1, str2);\n  if (ngramSim < threshold - 0.2) return false; // Early rejection\n\n  // Calculate actual edit distance only if n-gram similarity is promising\n  const distance = calculateLevenshteinDistance(str1, str2, maxDistance);\n  const similarity = distanceToSimilarity(distance, maxLen);\n\n  return similarity >= threshold;\n}\n","/**\n * Inverted Index Implementation\n * Optimized for large datasets (1M+ words)\n *\n * Architecture:\n * - Token → [docId1, docId2, ...] (posting lists)\n * - Fast intersection/union operations\n * - BM25-like scoring for relevance\n * - Parallel to existing hash-based index (backwards compatible)\n */\n\nimport type {\n  //\n  InvertedIndex,\n  DocumentMetadata,\n  PostingList,\n  FuzzyConfig,\n  LanguageProcessor,\n  SearchMatch,\n} from \"./types.js\";\nimport {\n  //\n  calculateLevenshteinDistance,\n} from \"../algorithms/levenshtein.js\";\n\n/**\n * Build inverted index from documents\n * This runs ALONGSIDE the existing index building\n */\nexport function buildInvertedIndex(words: string[], languageProcessors: LanguageProcessor[], config: FuzzyConfig, featureSet: Set<string>): { invertedIndex: InvertedIndex; documents: DocumentMetadata[] } {\n  const documents: DocumentMetadata[] = [];\n  const invertedIndex: InvertedIndex = {\n    termToPostings: new Map(),\n    phoneticToPostings: new Map(),\n    ngramToPostings: new Map(),\n    synonymToPostings: new Map(),\n    fieldIndices: new Map(),\n    totalDocs: 0,\n    avgDocLength: 0,\n  };\n\n  let totalLength = 0;\n  let docId = 0;\n\n  // Build documents and posting lists\n  for (const word of words) {\n    if (!word || word.trim().length < config.minQueryLength) continue;\n\n    const trimmedWord = word.trim();\n\n    // Process with each language processor\n    for (const processor of languageProcessors) {\n      const normalized = processor.normalize(trimmedWord);\n      const phoneticCode = featureSet.has(\"phonetic\") && processor.supportedFeatures.includes(\"phonetic\") ? processor.getPhoneticCode(trimmedWord) : undefined;\n\n      const compoundParts = featureSet.has(\"compound\") && processor.supportedFeatures.includes(\"compound\") ? processor.splitCompoundWords(trimmedWord) : undefined;\n\n      // Create document metadata\n      const doc: DocumentMetadata = {\n        id: docId,\n        word: trimmedWord,\n        normalized,\n        phoneticCode,\n        language: processor.language,\n        compoundParts: compoundParts && compoundParts.length > 1 ? compoundParts : undefined,\n      };\n\n      documents.push(doc);\n      totalLength += normalized.length;\n\n      // Index the normalized term\n      addToPostingList(invertedIndex.termToPostings, normalized, docId);\n\n      // Index original word (for exact matching)\n      addToPostingList(invertedIndex.termToPostings, trimmedWord.toLowerCase(), docId);\n\n      // Index word variants (prefixes)\n      if (featureSet.has(\"partial-words\")) {\n        const variants = processor.getWordVariants(trimmedWord);\n        variants.forEach((variant) => {\n          addToPostingList(invertedIndex.termToPostings, variant, docId);\n        });\n      }\n\n      // Index phonetic code\n      if (phoneticCode) {\n        addToPostingList(invertedIndex.phoneticToPostings, phoneticCode, docId);\n      }\n\n      // Index n-grams\n      const ngrams = generateNgrams(normalized, config.ngramSize);\n      ngrams.forEach((ngram) => {\n        addToPostingList(invertedIndex.ngramToPostings, ngram, docId);\n      });\n\n      // Index compound parts\n      if (compoundParts && compoundParts.length > 1) {\n        compoundParts.forEach((part) => {\n          const normalizedPart = processor.normalize(part);\n          addToPostingList(invertedIndex.termToPostings, normalizedPart, docId);\n        });\n      }\n\n      // Index synonyms\n      if (featureSet.has(\"synonyms\")) {\n        const synonyms = processor.getSynonyms(normalized);\n        synonyms.forEach((synonym) => {\n          addToPostingList(invertedIndex.synonymToPostings, synonym, docId);\n        });\n\n        // Custom synonyms\n        if (config.customSynonyms) {\n          const customSynonyms = config.customSynonyms[normalized];\n          if (customSynonyms) {\n            customSynonyms.forEach((synonym) => {\n              addToPostingList(invertedIndex.synonymToPostings, synonym, docId);\n            });\n          }\n        }\n      }\n\n      docId++;\n    }\n  }\n\n  invertedIndex.totalDocs = docId;\n  invertedIndex.avgDocLength = totalLength / Math.max(1, docId);\n\n  return { invertedIndex, documents };\n}\n\n/**\n * Search using inverted index\n * Much faster than hash-based approach for large datasets\n */\nexport function searchInvertedIndex(invertedIndex: InvertedIndex, documents: DocumentMetadata[], query: string, processors: LanguageProcessor[], config: FuzzyConfig): SearchMatch[] {\n  const matches = new Map<number, SearchMatch>();\n  const featureSet = new Set(config.features);\n\n  // Process query with each language processor\n  for (const processor of processors) {\n    const normalizedQuery = processor.normalize(query.trim());\n\n    // 1. Exact term lookup (fastest)\n    findExactMatchesInverted(normalizedQuery, invertedIndex, documents, matches, processor.language);\n\n    // 2. Prefix matches\n    findPrefixMatchesInverted(normalizedQuery, invertedIndex, documents, matches, processor.language);\n\n    // 3. Phonetic matches\n    if (featureSet.has(\"phonetic\") && processor.supportedFeatures.includes(\"phonetic\")) {\n      findPhoneticMatchesInverted(normalizedQuery, processor, invertedIndex, documents, matches);\n    }\n\n    // 4. Synonym matches\n    if (featureSet.has(\"synonyms\")) {\n      findSynonymMatchesInverted(normalizedQuery, invertedIndex, documents, matches);\n    }\n\n    // 5. N-gram matches\n    findNgramMatchesInverted(normalizedQuery, invertedIndex, documents, matches, processor.language, config.ngramSize);\n\n    // 6. Fuzzy matches (most expensive, do last)\n    if (featureSet.has(\"missing-letters\") || featureSet.has(\"extra-letters\") || featureSet.has(\"transpositions\")) {\n      findFuzzyMatchesInverted(normalizedQuery, invertedIndex, documents, matches, processor, config.maxEditDistance);\n    }\n  }\n\n  // Convert to array and return\n  return Array.from(matches.values());\n}\n\n/**\n * Helper: Add document to posting list\n */\nfunction addToPostingList(postings: Map<string, PostingList>, term: string, docId: number): void {\n  let posting = postings.get(term);\n  if (!posting) {\n    posting = { term, docIds: [] };\n    postings.set(term, posting);\n  }\n\n  // Avoid duplicates\n  if (!posting.docIds.includes(docId)) {\n    posting.docIds.push(docId);\n  }\n}\n\n/**\n * Helper: Generate n-grams\n */\nfunction generateNgrams(str: string, n: number): string[] {\n  if (str.length < n) return [str];\n  const ngrams: string[] = [];\n  for (let i = 0; i <= str.length - n; i++) {\n    ngrams.push(str.slice(i, i + n));\n  }\n  return ngrams;\n}\n\n/**\n * Find exact matches in inverted index\n */\nfunction findExactMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>, language: string): void {\n  const posting = invertedIndex.termToPostings.get(query);\n  if (!posting) return;\n\n  posting.docIds.forEach((docId) => {\n    const doc = documents[docId];\n    if (!doc) return;\n\n    if (!matches.has(docId)) {\n      matches.set(docId, {\n        word: doc.word,\n        normalized: query,\n        matchType: \"exact\",\n        editDistance: 0,\n        language,\n      });\n    }\n  });\n}\n\n/**\n * Find prefix matches in inverted index\n */\nfunction findPrefixMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>, language: string): void {\n  // Iterate through all terms and check for prefix\n  // Note: This could be optimized with a Trie, but for now we keep it simple\n  for (const [term, posting] of invertedIndex.termToPostings.entries()) {\n    if (term.startsWith(query) && term !== query) {\n      posting.docIds.forEach((docId) => {\n        const doc = documents[docId];\n        if (!doc) return;\n\n        if (!matches.has(docId)) {\n          matches.set(docId, {\n            word: doc.word,\n            normalized: term,\n            matchType: \"prefix\",\n            language,\n          });\n        }\n      });\n    }\n  }\n}\n\n/**\n * Find phonetic matches in inverted index\n */\nfunction findPhoneticMatchesInverted(query: string, processor: LanguageProcessor, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>): void {\n  const phoneticCode = processor.getPhoneticCode(query);\n  if (!phoneticCode) return;\n\n  const posting = invertedIndex.phoneticToPostings.get(phoneticCode);\n  if (!posting) return;\n\n  posting.docIds.forEach((docId) => {\n    const doc = documents[docId];\n    if (!doc) return;\n\n    if (!matches.has(docId)) {\n      matches.set(docId, {\n        word: doc.word,\n        normalized: query,\n        matchType: \"phonetic\",\n        phoneticCode,\n        language: processor.language,\n      });\n    }\n  });\n}\n\n/**\n * Find synonym matches in inverted index\n */\nfunction findSynonymMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>): void {\n  const posting = invertedIndex.synonymToPostings.get(query);\n  if (!posting) return;\n\n  posting.docIds.forEach((docId) => {\n    const doc = documents[docId];\n    if (!doc) return;\n\n    if (!matches.has(docId)) {\n      matches.set(docId, {\n        word: doc.word,\n        normalized: query,\n        matchType: \"synonym\",\n        language: \"synonym\",\n      });\n    }\n  });\n}\n\n/**\n * Find n-gram matches in inverted index\n */\nfunction findNgramMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>, language: string, ngramSize: number): void {\n  if (query.length < ngramSize) return;\n\n  const queryNgrams = generateNgrams(query, ngramSize);\n  const candidateDocs = new Set<number>();\n\n  // Collect all documents that contain at least one n-gram\n  queryNgrams.forEach((ngram) => {\n    const posting = invertedIndex.ngramToPostings.get(ngram);\n    if (posting) {\n      posting.docIds.forEach((docId) => candidateDocs.add(docId));\n    }\n  });\n\n  // Add to matches\n  candidateDocs.forEach((docId) => {\n    const doc = documents[docId];\n    if (!doc) return;\n\n    if (!matches.has(docId)) {\n      matches.set(docId, {\n        word: doc.word,\n        normalized: query,\n        matchType: \"ngram\",\n        language,\n      });\n    }\n  });\n}\n\n/**\n * Find fuzzy matches in inverted index\n * This is still O(n) but with better cache locality\n */\nfunction findFuzzyMatchesInverted(query: string, invertedIndex: InvertedIndex, documents: DocumentMetadata[], matches: Map<number, SearchMatch>, processor: LanguageProcessor, maxDistance: number): void {\n  // Iterate through all terms\n  for (const [term, posting] of invertedIndex.termToPostings.entries()) {\n    // Quick length check\n    if (Math.abs(term.length - query.length) > maxDistance) continue;\n\n    const distance = calculateLevenshteinDistance(query, term, maxDistance);\n    if (distance <= maxDistance) {\n      posting.docIds.forEach((docId) => {\n        const doc = documents[docId];\n        if (!doc) return;\n\n        const existingMatch = matches.get(docId);\n        if (!existingMatch || (existingMatch.editDistance || Infinity) > distance) {\n          matches.set(docId, {\n            word: doc.word,\n            normalized: term,\n            matchType: \"fuzzy\",\n            editDistance: distance,\n            language: processor.language,\n          });\n        }\n      });\n    }\n  }\n}\n","/**\n * Match Highlighting Utilities\n * Calculates positions of matched characters for UI highlighting\n */\n\nimport type { MatchHighlight, MatchType, SearchMatch } from \"./types.js\";\n\n/**\n * Calculate highlights for a search match\n */\nexport function calculateHighlights(\n  match: SearchMatch,\n  query: string,\n  displayText: string\n): MatchHighlight[] {\n  const highlights: MatchHighlight[] = [];\n  const normalizedDisplay = displayText.toLowerCase();\n  const normalizedQuery = query.toLowerCase();\n\n  switch (match.matchType) {\n    case \"exact\":\n      // Highlight the entire word\n      highlights.push({\n        start: 0,\n        end: displayText.length,\n        type: \"exact\",\n      });\n      break;\n\n    case \"prefix\":\n      // Highlight the matching prefix\n      const prefixEnd = Math.min(normalizedQuery.length, displayText.length);\n      highlights.push({\n        start: 0,\n        end: prefixEnd,\n        type: \"prefix\",\n      });\n      break;\n\n    case \"substring\":\n      // Find where the query appears in the display text\n      const substringIndex = normalizedDisplay.indexOf(normalizedQuery);\n      if (substringIndex !== -1) {\n        highlights.push({\n          start: substringIndex,\n          end: substringIndex + normalizedQuery.length,\n          type: \"substring\",\n        });\n      }\n      break;\n\n    case \"fuzzy\":\n      // For fuzzy matches, highlight matching characters\n      highlights.push(...calculateFuzzyHighlights(normalizedQuery, normalizedDisplay, \"fuzzy\"));\n      break;\n\n    case \"ngram\":\n      // Highlight n-gram matches\n      highlights.push(...calculateNgramHighlights(normalizedQuery, normalizedDisplay));\n      break;\n\n    case \"phonetic\":\n    case \"synonym\":\n    case \"compound\":\n      // For phonetic/synonym/compound, highlight the whole word\n      highlights.push({\n        start: 0,\n        end: displayText.length,\n        type: match.matchType,\n      });\n      break;\n  }\n\n  return mergeOverlappingHighlights(highlights);\n}\n\n/**\n * Calculate highlights for fuzzy matches using edit distance alignment\n */\nfunction calculateFuzzyHighlights(\n  query: string,\n  text: string,\n  type: MatchType\n): MatchHighlight[] {\n  const highlights: MatchHighlight[] = [];\n  let queryIdx = 0;\n  let textIdx = 0;\n\n  // Simple greedy matching - find matching characters\n  while (queryIdx < query.length && textIdx < text.length) {\n    if (query[queryIdx] === text[textIdx]) {\n      // Found a match\n      const start = textIdx;\n      let end = textIdx + 1;\n\n      // Extend the match as far as possible\n      queryIdx++;\n      textIdx++;\n      while (queryIdx < query.length && textIdx < text.length && query[queryIdx] === text[textIdx]) {\n        end++;\n        queryIdx++;\n        textIdx++;\n      }\n\n      highlights.push({ start, end, type });\n    } else {\n      textIdx++;\n    }\n  }\n\n  return highlights;\n}\n\n/**\n * Calculate highlights for n-gram matches\n */\nfunction calculateNgramHighlights(\n  query: string,\n  text: string\n): MatchHighlight[] {\n  const highlights: MatchHighlight[] = [];\n  const ngramSize = 3;\n\n  // Find all n-grams from query that appear in text\n  for (let i = 0; i <= query.length - ngramSize; i++) {\n    const ngram = query.slice(i, i + ngramSize);\n    let searchStart = 0;\n\n    // Find all occurrences of this n-gram\n    while (true) {\n      const index = text.indexOf(ngram, searchStart);\n      if (index === -1) break;\n\n      highlights.push({\n        start: index,\n        end: index + ngramSize,\n        type: \"ngram\",\n      });\n\n      searchStart = index + 1;\n    }\n  }\n\n  return highlights;\n}\n\n/**\n * Merge overlapping highlights to avoid duplicate highlighting\n */\nfunction mergeOverlappingHighlights(highlights: MatchHighlight[]): MatchHighlight[] {\n  if (highlights.length === 0) return [];\n\n  // Sort by start position\n  const sorted = [...highlights].sort((a, b) => a.start - b.start);\n  const merged: MatchHighlight[] = [sorted[0]];\n\n  for (let i = 1; i < sorted.length; i++) {\n    const current = sorted[i];\n    const last = merged[merged.length - 1];\n\n    if (current.start <= last.end) {\n      // Overlapping - merge them\n      last.end = Math.max(last.end, current.end);\n      // Keep the more specific match type\n      if (getMatchTypePriority(current.type) > getMatchTypePriority(last.type)) {\n        last.type = current.type;\n      }\n    } else {\n      // No overlap - add as new highlight\n      merged.push(current);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Get priority for match types (higher = more specific)\n */\nfunction getMatchTypePriority(type: MatchType): number {\n  const priorities: Record<MatchType, number> = {\n    exact: 10,\n    prefix: 9,\n    substring: 8,\n    fuzzy: 7,\n    ngram: 6,\n    phonetic: 5,\n    compound: 4,\n    synonym: 3,\n  };\n  return priorities[type] || 0;\n}\n\n/**\n * Format highlighted text for HTML rendering\n */\nexport function formatHighlightedHTML(\n  text: string,\n  highlights: MatchHighlight[],\n  className: string = \"highlight\"\n): string {\n  if (!highlights || highlights.length === 0) {\n    return escapeHTML(text);\n  }\n\n  let result = \"\";\n  let lastEnd = 0;\n\n  for (const highlight of highlights) {\n    // Add text before highlight\n    if (highlight.start > lastEnd) {\n      result += escapeHTML(text.slice(lastEnd, highlight.start));\n    }\n\n    // Add highlighted text\n    const highlightedText = text.slice(highlight.start, highlight.end);\n    result += `<mark class=\"${className} ${className}--${highlight.type}\">${escapeHTML(highlightedText)}</mark>`;\n\n    lastEnd = highlight.end;\n  }\n\n  // Add remaining text\n  if (lastEnd < text.length) {\n    result += escapeHTML(text.slice(lastEnd));\n  }\n\n  return result;\n}\n\n/**\n * Escape HTML special characters\n */\nfunction escapeHTML(text: string): string {\n  const div = typeof document !== \"undefined\" ? document.createElement(\"div\") : null;\n  if (div) {\n    div.textContent = text;\n    return div.innerHTML;\n  }\n  // Fallback for Node.js\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\");\n}\n","/**\n * LRU Cache for Search Results\n * Provides 10-100x speedup for repeated queries (e.g., autocomplete)\n */\n\nimport type { SuggestionResult } from \"./types.js\";\n\n/**\n * LRU (Least Recently Used) Cache\n * Automatically evicts oldest entries when capacity is reached\n */\nexport class LRUCache<K, V> {\n  private cache: Map<K, V>;\n  private capacity: number;\n\n  constructor(capacity: number = 100) {\n    this.cache = new Map();\n    this.capacity = capacity;\n  }\n\n  /**\n   * Get value from cache\n   * Moves item to end (most recently used)\n   */\n  get(key: K): V | undefined {\n    if (!this.cache.has(key)) {\n      return undefined;\n    }\n\n    // Move to end (most recently used)\n    const value = this.cache.get(key)!;\n    this.cache.delete(key);\n    this.cache.set(key, value);\n\n    return value;\n  }\n\n  /**\n   * Set value in cache\n   * Evicts oldest entry if capacity exceeded\n   */\n  set(key: K, value: V): void {\n    // Remove if exists (to update position)\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    // Add to end (most recently used)\n    this.cache.set(key, value);\n\n    // Evict oldest if over capacity\n    if (this.cache.size > this.capacity) {\n      const firstKey = this.cache.keys().next().value as K;\n      if (firstKey !== undefined) {\n        this.cache.delete(firstKey);\n      }\n    }\n  }\n\n  /**\n   * Check if key exists in cache\n   */\n  has(key: K): boolean {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Clear all cached entries\n   */\n  clear(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get current cache size\n   */\n  get size(): number {\n    return this.cache.size;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): { size: number; capacity: number; utilization: number } {\n    return {\n      size: this.cache.size,\n      capacity: this.capacity,\n      utilization: this.cache.size / this.capacity,\n    };\n  }\n}\n\n/**\n * Search Result Cache\n * Caches search results with automatic invalidation\n */\nexport class SearchCache {\n  private cache: LRUCache<string, SuggestionResult[]>;\n  private hits: number = 0;\n  private misses: number = 0;\n\n  constructor(capacity: number = 100) {\n    this.cache = new LRUCache(capacity);\n  }\n\n  /**\n   * Generate cache key from query and options\n   */\n  private getCacheKey(query: string, maxResults?: number, options?: any): string {\n    const optionsKey = options ? JSON.stringify(options) : \"\";\n    return `${query}|${maxResults || \"default\"}|${optionsKey}`;\n  }\n\n  /**\n   * Get cached results\n   */\n  get(query: string, maxResults?: number, options?: any): SuggestionResult[] | undefined {\n    const key = this.getCacheKey(query, maxResults, options);\n    const result = this.cache.get(key);\n\n    if (result) {\n      this.hits++;\n    } else {\n      this.misses++;\n    }\n\n    return result;\n  }\n\n  /**\n   * Set cached results\n   */\n  set(query: string, results: SuggestionResult[], maxResults?: number, options?: any): void {\n    const key = this.getCacheKey(query, maxResults, options);\n    this.cache.set(key, results);\n  }\n\n  /**\n   * Clear cache\n   */\n  clear(): void {\n    this.cache.clear();\n    this.hits = 0;\n    this.misses = 0;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): {\n    size: number;\n    capacity: number;\n    hits: number;\n    misses: number;\n    hitRate: number;\n  } {\n    const cacheStats = this.cache.getStats();\n    const total = this.hits + this.misses;\n    const hitRate = total > 0 ? this.hits / total : 0;\n\n    return {\n      ...cacheStats,\n      hits: this.hits,\n      misses: this.misses,\n      hitRate,\n    };\n  }\n}\n","/**\n * Accent Normalization Utilities\n * Removes diacritics and accents from text for better matching\n */\n\n/**\n * Comprehensive accent/diacritic mapping\n * Maps accented characters to their base forms\n */\nconst ACCENT_MAP: Record<string, string> = {\n  // Latin Extended-A\n  à: \"a\",\n  á: \"a\",\n  â: \"a\",\n  ã: \"a\",\n  ä: \"a\",\n  å: \"a\",\n  ā: \"a\",\n  ă: \"a\",\n  ą: \"a\",\n  À: \"A\",\n  Á: \"A\",\n  Â: \"A\",\n  Ã: \"A\",\n  Ä: \"A\",\n  Å: \"A\",\n  Ā: \"A\",\n  Ă: \"A\",\n  Ą: \"A\",\n\n  è: \"e\",\n  é: \"e\",\n  ê: \"e\",\n  ë: \"e\",\n  ē: \"e\",\n  ĕ: \"e\",\n  ė: \"e\",\n  ę: \"e\",\n  ě: \"e\",\n  È: \"E\",\n  É: \"E\",\n  Ê: \"E\",\n  Ë: \"E\",\n  Ē: \"E\",\n  Ĕ: \"E\",\n  Ė: \"E\",\n  Ę: \"E\",\n  Ě: \"E\",\n\n  ì: \"i\",\n  í: \"i\",\n  î: \"i\",\n  ï: \"i\",\n  ĩ: \"i\",\n  ī: \"i\",\n  ĭ: \"i\",\n  į: \"i\",\n  Ì: \"I\",\n  Í: \"I\",\n  Î: \"I\",\n  Ï: \"I\",\n  Ĩ: \"I\",\n  Ī: \"I\",\n  Ĭ: \"I\",\n  Į: \"I\",\n\n  'ò': 'o', 'ó': 'o', 'ô': 'o', 'õ': 'o', 'ö': 'o', 'ø': 'o', 'ō': 'o', 'ŏ': 'o', 'ő': 'o',\n  'Ò': 'O', 'Ó': 'O', 'Ô': 'O', 'Õ': 'O', 'Ö': 'O', 'Ø': 'O', 'Ō': 'O', 'Ŏ': 'O', 'Ő': 'O',\n\n  'ù': 'u', 'ú': 'u', 'û': 'u', 'ü': 'u', 'ũ': 'u', 'ū': 'u', 'ŭ': 'u', 'ů': 'u', 'ű': 'u', 'ų': 'u',\n  'Ù': 'U', 'Ú': 'U', 'Û': 'U', 'Ü': 'U', 'Ũ': 'U', 'Ū': 'U', 'Ŭ': 'U', 'Ů': 'U', 'Ű': 'U', 'Ų': 'U',\n\n  ý: \"y\",\n  ÿ: \"y\",\n  ŷ: \"y\",\n  Ý: \"Y\",\n  Ÿ: \"Y\",\n  Ŷ: \"Y\",\n\n  ñ: \"n\",\n  ń: \"n\",\n  ņ: \"n\",\n  ň: \"n\",\n  Ñ: \"N\",\n  Ń: \"N\",\n  Ņ: \"N\",\n  Ň: \"N\",\n\n  ç: \"c\",\n  ć: \"c\",\n  ĉ: \"c\",\n  ċ: \"c\",\n  č: \"c\",\n  Ç: \"C\",\n  Ć: \"C\",\n  Ĉ: \"C\",\n  Ċ: \"C\",\n  Č: \"C\",\n\n  ß: \"ss\", // German sharp s\n\n  ð: \"d\",\n  đ: \"d\",\n  Ð: \"D\",\n  Đ: \"D\",\n\n  ĝ: \"g\",\n  ğ: \"g\",\n  ġ: \"g\",\n  ģ: \"g\",\n  Ĝ: \"G\",\n  Ğ: \"G\",\n  Ġ: \"G\",\n  Ģ: \"G\",\n\n  ĥ: \"h\",\n  ħ: \"h\",\n  Ĥ: \"H\",\n  Ħ: \"H\",\n\n  ĵ: \"j\",\n  Ĵ: \"J\",\n\n  ķ: \"k\",\n  Ķ: \"K\",\n\n  ĺ: \"l\",\n  ļ: \"l\",\n  ľ: \"l\",\n  ŀ: \"l\",\n  ł: \"l\",\n  Ĺ: \"L\",\n  Ļ: \"L\",\n  Ľ: \"L\",\n  Ŀ: \"L\",\n  Ł: \"L\",\n\n  ŕ: \"r\",\n  ŗ: \"r\",\n  ř: \"r\",\n  Ŕ: \"R\",\n  Ŗ: \"R\",\n  Ř: \"R\",\n\n  ś: \"s\",\n  ŝ: \"s\",\n  ş: \"s\",\n  š: \"s\",\n  Ś: \"S\",\n  Ŝ: \"S\",\n  Ş: \"S\",\n  Š: \"S\",\n\n  ţ: \"t\",\n  ť: \"t\",\n  ŧ: \"t\",\n  Ţ: \"T\",\n  Ť: \"T\",\n  Ŧ: \"T\",\n\n  ŵ: \"w\",\n  Ŵ: \"W\",\n\n  ź: \"z\",\n  ż: \"z\",\n  ž: \"z\",\n  Ź: \"Z\",\n  Ż: \"Z\",\n  Ž: \"Z\",\n\n  æ: \"ae\",\n  œ: \"oe\",\n  Æ: \"AE\",\n  Œ: \"OE\",\n\n  þ: \"th\",\n  Þ: \"TH\",\n};\n\n/**\n * Remove accents and diacritics from a string\n * Uses both custom mapping and Unicode normalization\n */\nexport function removeAccents(text: string): string {\n  if (!text) return text;\n\n  // First pass: Use custom accent map for known characters\n  let result = \"\";\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    result += ACCENT_MAP[char] || char;\n  }\n\n  // Second pass: Use Unicode normalization for any remaining accents\n  // NFD = Canonical Decomposition (separates base char from combining marks)\n  // Then remove combining diacritical marks (Unicode range \\u0300-\\u036f)\n  result = result.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n\n  return result;\n}\n\n/**\n * Check if a string contains any accented characters\n */\nexport function hasAccents(text: string): boolean {\n  if (!text) return false;\n\n  // Check custom map\n  for (let i = 0; i < text.length; i++) {\n    if (ACCENT_MAP[text[i]]) {\n      return true;\n    }\n  }\n\n  // Check for combining diacritical marks\n  const normalized = text.normalize(\"NFD\");\n  return /[\\u0300-\\u036f]/.test(normalized);\n}\n\n/**\n * Normalize text for accent-insensitive comparison\n * Converts to lowercase and removes accents\n */\nexport function normalizeForComparison(text: string): string {\n  return removeAccents(text.toLowerCase());\n}\n\n/**\n * Create accent-insensitive variants of a word\n * Returns both original and accent-free version\n */\nexport function getAccentVariants(word: string): string[] {\n  const normalized = removeAccents(word);\n\n  // If word has accents, return both versions\n  if (normalized !== word) {\n    return [word, normalized];\n  }\n\n  // Otherwise just return original\n  return [word];\n}\n","/**\n * Field Weighting Utilities\n * Support for multi-field search with weighted scoring\n */\n\n/**\n * Extract field values from an object or string\n */\nexport function extractFieldValues(\n  item: any,\n  fields?: string[]\n): Record<string, string> | null {\n  // If no fields specified, treat item as simple string\n  if (!fields || fields.length === 0) {\n    return null;\n  }\n\n  // If item is a string, can't extract fields\n  if (typeof item === 'string') {\n    return null;\n  }\n\n  // If item is an object, extract field values\n  if (typeof item === 'object' && item !== null) {\n    const fieldValues: Record<string, string> = {};\n    \n    for (const field of fields) {\n      const value = item[field];\n      if (value !== undefined && value !== null) {\n        fieldValues[field] = String(value);\n      }\n    }\n    \n    return Object.keys(fieldValues).length > 0 ? fieldValues : null;\n  }\n\n  return null;\n}\n\n/**\n * Get all searchable text from field values\n */\nexport function getSearchableText(fieldValues: Record<string, string>): string[] {\n  return Object.values(fieldValues).filter(v => v && v.trim().length > 0);\n}\n\n/**\n * Normalize field weights (ensure all fields have a weight)\n */\nexport function normalizeFieldWeights(\n  fields: string[],\n  fieldWeights?: Record<string, number>\n): Record<string, number> {\n  const normalized: Record<string, number> = {};\n  \n  for (const field of fields) {\n    normalized[field] = fieldWeights?.[field] ?? 1.0;\n  }\n  \n  return normalized;\n}\n\n/**\n * Apply field weight to a score\n */\nexport function applyFieldWeight(\n  baseScore: number,\n  fieldWeight: number\n): number {\n  return Math.min(1.0, baseScore * fieldWeight);\n}\n","/**\n * Stop Words Filtering\n * Common words that should be ignored in search queries\n */\n\n/**\n * Default stop words by language\n */\nexport const DEFAULT_STOP_WORDS: Record<string, string[]> = {\n  english: [\n    //\n    \"a\",\n    \"an\",\n    \"and\",\n    \"are\",\n    \"as\",\n    \"at\",\n    \"be\",\n    \"by\",\n    \"for\",\n    \"from\",\n    \"has\",\n    \"he\",\n    \"in\",\n    \"is\",\n    \"it\",\n    \"its\",\n    \"of\",\n    \"on\",\n    \"that\",\n    \"the\",\n    \"to\",\n    \"was\",\n    \"will\",\n    \"with\",\n    \"the\",\n    \"this\",\n    \"but\",\n    \"they\",\n    \"have\",\n    \"had\",\n    \"what\",\n    \"when\",\n    \"where\",\n    \"who\",\n    \"which\",\n    \"why\",\n    \"how\",\n  ],\n  german: [\n    //\n    \"der\",\n    \"die\",\n    \"das\",\n    \"den\",\n    \"dem\",\n    \"des\",\n    \"ein\",\n    \"eine\",\n    \"einer\",\n    \"eines\",\n    \"einem\",\n    \"einen\",\n    \"und\",\n    \"oder\",\n    \"aber\",\n    \"ist\",\n    \"sind\",\n    \"war\",\n    \"waren\",\n    \"hat\",\n    \"haben\",\n    \"wird\",\n    \"werden\",\n    \"von\",\n    \"zu\",\n    \"im\",\n    \"am\",\n    \"um\",\n    \"auf\",\n    \"für\",\n    \"mit\",\n    \"nach\",\n    \"bei\",\n    \"aus\",\n  ],\n  spanish: [\n    //\n    \"el\",\n    \"la\",\n    \"los\",\n    \"las\",\n    \"un\",\n    \"una\",\n    \"unos\",\n    \"unas\",\n    \"de\",\n    \"del\",\n    \"y\",\n    \"o\",\n    \"pero\",\n    \"es\",\n    \"son\",\n    \"era\",\n    \"fueron\",\n    \"ha\",\n    \"han\",\n    \"en\",\n    \"a\",\n    \"al\",\n    \"con\",\n    \"por\",\n    \"para\",\n    \"sin\",\n    \"sobre\",\n    \"entre\",\n  ],\n  french: [\n    //\n    \"le\",\n    \"la\",\n    \"les\",\n    \"un\",\n    \"une\",\n    \"des\",\n    \"du\",\n    \"de\",\n    \"et\",\n    \"ou\",\n    \"mais\",\n    \"est\",\n    \"sont\",\n    \"était\",\n    \"étaient\",\n    \"a\",\n    \"ont\",\n    \"à\",\n    \"au\",\n    \"aux\",\n    \"avec\",\n    \"pour\",\n    \"par\",\n    \"dans\",\n    \"sur\",\n    \"sous\",\n    \"entre\",\n  ],\n};\n\n/**\n * Filter stop words from a query\n */\nexport function filterStopWords(\n  query: string,\n  stopWords: string[] | Set<string>\n): string {\n  const stopWordsSet = stopWords instanceof Set ? stopWords : new Set(stopWords.map(w => w.toLowerCase()));\n  \n  // Split query into words, preserving original case\n  const words = query.split(/\\s+/);\n  const filtered = words.filter(word => !stopWordsSet.has(word.toLowerCase()));\n  \n  // If all words are stop words, return original query to avoid empty search\n  if (filtered.length === 0) {\n    return query;\n  }\n  \n  return filtered.join(' ');\n}\n\n/**\n * Get stop words for specific languages\n */\nexport function getStopWordsForLanguages(languages: string[]): Set<string> {\n  const stopWords = new Set<string>();\n\n  for (const lang of languages) {\n    const langStopWords = DEFAULT_STOP_WORDS[lang.toLowerCase()];\n    if (langStopWords) {\n      langStopWords.forEach((word) => stopWords.add(word));\n    }\n  }\n\n  return stopWords;\n}\n\n/**\n * Check if a word is a stop word\n */\nexport function isStopWord(word: string, stopWords: string[] | Set<string>): boolean {\n  const stopWordsSet = stopWords instanceof Set ? stopWords : new Set(stopWords.map((w) => w.toLowerCase()));\n  return stopWordsSet.has(word.toLowerCase());\n}\n","/**\n * Word Boundary Utilities\n * Check if matches occur at word boundaries for more precise results\n */\n\n/**\n * Check if a match is at a word boundary\n * A word boundary is:\n * - Start of string\n * - After whitespace\n * - After punctuation\n */\nexport function isWordBoundary(text: string, position: number): boolean {\n  // Start of string is always a word boundary\n  if (position === 0) {\n    return true;\n  }\n\n  // Check the character before the position\n  const charBefore = text[position - 1];\n  \n  // Word boundary if previous character is whitespace or punctuation\n  return /[\\s\\-_.,;:!?()[\\]{}'\"\\/\\\\]/.test(charBefore);\n}\n\n/**\n * Check if a match occurs at word boundaries (both start and end)\n */\nexport function matchesAtWordBoundary(\n  text: string,\n  matchStart: number,\n  matchLength: number\n): boolean {\n  const matchEnd = matchStart + matchLength;\n  \n  // Check start boundary\n  const startBoundary = isWordBoundary(text, matchStart);\n  \n  // Check end boundary (either end of string or followed by boundary character)\n  const endBoundary = matchEnd >= text.length || /[\\s\\-_.,;:!?()[\\]{}'\"\\/\\\\]/.test(text[matchEnd]);\n  \n  return startBoundary && endBoundary;\n}\n\n/**\n * Find all word boundary matches of a pattern in text\n */\nexport function findWordBoundaryMatches(\n  text: string,\n  pattern: string,\n  caseSensitive: boolean = false\n): number[] {\n  const positions: number[] = [];\n  const searchText = caseSensitive ? text : text.toLowerCase();\n  const searchPattern = caseSensitive ? pattern : pattern.toLowerCase();\n  \n  let index = 0;\n  while (index < searchText.length) {\n    const found = searchText.indexOf(searchPattern, index);\n    \n    if (found === -1) {\n      break;\n    }\n    \n    // Check if this match is at a word boundary\n    if (matchesAtWordBoundary(text, found, searchPattern.length)) {\n      positions.push(found);\n    }\n    \n    index = found + 1;\n  }\n  \n  return positions;\n}\n\n/**\n * Check if query matches word with word boundaries\n */\nexport function matchesWord(word: string, query: string, wordBoundaries: boolean): boolean {\n  if (!wordBoundaries) {\n    // No word boundary checking - substring match is fine\n    return word.toLowerCase().includes(query.toLowerCase());\n  }\n  \n  // With word boundaries - must match at word boundary\n  const positions = findWordBoundaryMatches(word, query, false);\n  return positions.length > 0;\n}\n\n/**\n * Check if a word starts with query (prefix match with word boundaries)\n */\nexport function startsWithWord(word: string, query: string, wordBoundaries: boolean): boolean {\n  const wordLower = word.toLowerCase();\n  const queryLower = query.toLowerCase();\n  \n  if (!wordBoundaries) {\n    return wordLower.startsWith(queryLower);\n  }\n  \n  // With word boundaries - check if it starts at position 0 (which is always a boundary)\n  return wordLower.startsWith(queryLower);\n}\n\n/**\n * Parse wildcard pattern (supports * for any characters)\n */\nexport function parseWildcard(pattern: string): RegExp {\n  // Escape special regex characters except *\n  const escaped = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  \n  // Replace * with .*\n  const regexPattern = escaped.replace(/\\*/g, '.*');\n  \n  // Create regex with word boundaries if no wildcards\n  return new RegExp(`^${regexPattern}$`, 'i');\n}\n\n/**\n * Check if word matches wildcard pattern\n */\nexport function matchesWildcard(word: string, pattern: string): boolean {\n  const regex = parseWildcard(pattern);\n  return regex.test(word);\n}\n","import type { FuzzyIndex, FuzzyConfig, SuggestionResult, SearchMatch, BuildIndexOptions, SearchOptions, LanguageProcessor } from \"./types.js\";\nimport { mergeConfig, validateConfig } from \"./config.js\";\nimport { LanguageRegistry } from \"../languages/index.js\";\nimport { calculateLevenshteinDistance, calculateNgramSimilarity } from \"../algorithms/levenshtein.js\";\nimport { buildInvertedIndex, searchInvertedIndex } from \"./inverted-index.js\";\nimport { calculateHighlights } from \"./highlighting.js\";\nimport { SearchCache } from \"./cache.js\";\nimport { removeAccents } from \"../utils/accent-normalization.js\";\nimport { extractFieldValues, normalizeFieldWeights } from \"./field-weighting.js\";\nimport { filterStopWords } from \"../utils/stop-words.js\";\nimport { matchesWord, matchesWildcard } from \"../utils/word-boundaries.js\";\n\n/**\n * Build a fuzzy search index from a dictionary of words or objects\n */\nexport function buildFuzzyIndex(words: (string | any)[] = [], options: BuildIndexOptions = {}): FuzzyIndex {\n  const config = mergeConfig(options.config);\n  validateConfig(config);\n\n  // Convert features array to Set for O(1) lookup performance\n  const featureSet = new Set(config.features);\n\n  const languageProcessors = options.languageProcessors || LanguageRegistry.getProcessors(config.languages);\n\n  if (languageProcessors.length === 0) {\n    throw new Error(`No language processors found for: ${config.languages.join(\", \")}`);\n  }\n\n  // Check if we're doing multi-field search\n  const hasFields = options.fields && options.fields.length > 0;\n  const isObjectArray = words.length > 0 && typeof words[0] === \"object\" && words[0] !== null;\n\n  // Validate: if objects are provided, fields must be specified\n  if (isObjectArray && !hasFields) {\n    throw new Error(\"When indexing objects, you must specify which fields to index via options.fields\");\n  }\n\n  const index: FuzzyIndex = {\n    base: [],\n    variantToBase: new Map(),\n    phoneticToBase: new Map(),\n    ngramIndex: new Map(),\n    synonymMap: new Map(),\n    languageProcessors: new Map(),\n    config,\n  };\n\n  // Store field configuration if provided\n  if (hasFields) {\n    index.fields = options.fields;\n    index.fieldWeights = normalizeFieldWeights(options.fields!, options.fieldWeights);\n    index.fieldData = new Map();\n  }\n\n  // Store language processors\n  languageProcessors.forEach((processor) => {\n    index.languageProcessors.set(processor.language, processor);\n  });\n\n  const processedWords = new Set<string>();\n  let processed = 0;\n\n  for (const item of words) {\n    if (!item) continue;\n\n    // Handle multi-field objects\n    if (hasFields && isObjectArray) {\n      const fieldValues = extractFieldValues(item, options.fields);\n      if (!fieldValues) continue;\n\n      // Generate a unique ID for this object (use first field value as base)\n      const baseId = Object.values(fieldValues)[0] || `item_${processed}`;\n\n      // Store field data\n      index.fieldData!.set(baseId, fieldValues);\n\n      // Index each field separately\n      for (const [fieldName, fieldValue] of Object.entries(fieldValues)) {\n        if (!fieldValue || fieldValue.trim().length < config.minQueryLength) continue;\n\n        const trimmedValue = fieldValue.trim();\n\n        // Add to base if not already there\n        if (!processedWords.has(baseId.toLowerCase())) {\n          processedWords.add(baseId.toLowerCase());\n          index.base.push(baseId);\n        }\n\n        // Process this field value with each language processor\n        for (const processor of languageProcessors) {\n          processWordWithProcessorAndField(trimmedValue, baseId, fieldName, processor, index, config, featureSet);\n        }\n      }\n    } else {\n      // Handle simple string array (backwards compatible)\n      const word = typeof item === \"string\" ? item : String(item);\n      if (word.trim().length < config.minQueryLength) continue;\n\n      const trimmedWord = word.trim();\n      if (processedWords.has(trimmedWord.toLowerCase())) continue;\n\n      processedWords.add(trimmedWord.toLowerCase());\n      index.base.push(trimmedWord);\n\n      // Process with each language processor\n      for (const processor of languageProcessors) {\n        processWordWithProcessor(trimmedWord, processor, index, config, featureSet);\n      }\n    }\n\n    processed++;\n    if (options.onProgress) {\n      options.onProgress(processed, words.length);\n    }\n  }\n\n  // INVERTED INDEX: Build if enabled or auto-enable for large datasets\n  const shouldUseInvertedIndex = options.useInvertedIndex || config.useInvertedIndex || words.length >= 10000; // Auto-enable for 10k+ words\n\n  if (shouldUseInvertedIndex) {\n    const { invertedIndex, documents } = buildInvertedIndex(words, languageProcessors, config, featureSet);\n    index.invertedIndex = invertedIndex;\n    index.documents = documents;\n  }\n\n  // CACHE: Initialize search result cache if enabled (default: true)\n  const enableCache = config.enableCache !== false; // Default to true\n  if (enableCache) {\n    const cacheSize = config.cacheSize || 100;\n    index._cache = new SearchCache(cacheSize);\n  }\n\n  return index;\n}\n\n/**\n * Process a word with a specific language processor\n */\nfunction processWordWithProcessor(word: string, processor: LanguageProcessor, index: FuzzyIndex, config: FuzzyConfig, featureSet: Set<string>): void {\n  const normalized = processor.normalize(word);\n\n  // Add base word mapping\n  addToVariantMap(index.variantToBase, normalized, word);\n  addToVariantMap(index.variantToBase, word.toLowerCase(), word);\n  // Also add the original word as-is for exact matching\n  addToVariantMap(index.variantToBase, word, word);\n\n  // Add accent-insensitive variants\n  const accentFreeWord = removeAccents(word);\n  if (accentFreeWord !== word) {\n    // Add the accent-free version in multiple forms\n    addToVariantMap(index.variantToBase, accentFreeWord, word); // Original case\n    addToVariantMap(index.variantToBase, accentFreeWord.toLowerCase(), word); // Lowercase\n    const normalizedAccentFree = processor.normalize(accentFreeWord);\n    if (normalizedAccentFree !== accentFreeWord.toLowerCase()) {\n      addToVariantMap(index.variantToBase, normalizedAccentFree, word); // Processor normalized\n    }\n  }\n\n  // Generate and index variants\n  if (featureSet.has(\"partial-words\")) {\n    const variants = processor.getWordVariants(word);\n    variants.forEach((variant) => {\n      addToVariantMap(index.variantToBase, variant, word);\n    });\n  }\n\n  // Generate phonetic codes\n  if (featureSet.has(\"phonetic\") && processor.supportedFeatures.includes(\"phonetic\")) {\n    const phoneticCode = processor.getPhoneticCode(word);\n    if (phoneticCode) {\n      addToVariantMap(index.phoneticToBase, phoneticCode, word);\n    }\n  }\n\n  // Generate n-grams for partial matching\n  const ngrams = generateNgrams(normalized, config.ngramSize);\n  ngrams.forEach((ngram: string) => {\n    addToVariantMap(index.ngramIndex, ngram, word);\n  });\n\n  // Handle compound words\n  if (featureSet.has(\"compound\") && processor.supportedFeatures.includes(\"compound\")) {\n    const compoundParts = processor.splitCompoundWords(word);\n    compoundParts.forEach((part) => {\n      if (part !== word) {\n        addToVariantMap(index.variantToBase, processor.normalize(part), word);\n      }\n    });\n  }\n\n  // Add synonyms\n  if (featureSet.has(\"synonyms\")) {\n    const synonyms = processor.getSynonyms(normalized);\n    synonyms.forEach((synonym) => {\n      addToVariantMap(index.synonymMap, synonym, word);\n    });\n\n    // Add custom synonyms\n    if (config.customSynonyms) {\n      const customSynonyms = config.customSynonyms[normalized];\n      if (customSynonyms) {\n        customSynonyms.forEach((synonym) => {\n          addToVariantMap(index.synonymMap, synonym, word);\n        });\n      }\n    }\n  }\n}\n\n/**\n * Process a word with field information for multi-field search\n */\nfunction processWordWithProcessorAndField(fieldValue: string, baseId: string, fieldName: string, processor: LanguageProcessor, index: FuzzyIndex, config: FuzzyConfig, featureSet: Set<string>): void {\n  const normalized = processor.normalize(fieldValue);\n\n  // Add base word mapping with field metadata\n  addToVariantMapWithField(index.variantToBase, normalized, baseId, fieldName);\n  addToVariantMapWithField(index.variantToBase, fieldValue.toLowerCase(), baseId, fieldName);\n  addToVariantMapWithField(index.variantToBase, fieldValue, baseId, fieldName);\n\n  // Add accent-insensitive variants\n  const accentFreeWord = removeAccents(fieldValue);\n  if (accentFreeWord !== fieldValue) {\n    addToVariantMapWithField(index.variantToBase, accentFreeWord, baseId, fieldName);\n    addToVariantMapWithField(index.variantToBase, accentFreeWord.toLowerCase(), baseId, fieldName);\n    const normalizedAccentFree = processor.normalize(accentFreeWord);\n    if (normalizedAccentFree !== accentFreeWord.toLowerCase()) {\n      addToVariantMapWithField(index.variantToBase, normalizedAccentFree, baseId, fieldName);\n    }\n  }\n\n  // Generate and index variants\n  if (featureSet.has(\"partial-words\")) {\n    const variants = processor.getWordVariants(fieldValue);\n    variants.forEach((variant) => {\n      addToVariantMapWithField(index.variantToBase, variant, baseId, fieldName);\n    });\n  }\n\n  // Generate phonetic codes\n  if (featureSet.has(\"phonetic\") && processor.supportedFeatures.includes(\"phonetic\")) {\n    const phoneticCode = processor.getPhoneticCode(fieldValue);\n    if (phoneticCode) {\n      addToVariantMapWithField(index.phoneticToBase, phoneticCode, baseId, fieldName);\n    }\n  }\n\n  // Generate n-grams for partial matching\n  const ngrams = generateNgrams(normalized, config.ngramSize);\n  ngrams.forEach((ngram: string) => {\n    addToVariantMapWithField(index.ngramIndex, ngram, baseId, fieldName);\n  });\n\n  // Handle compound words\n  if (featureSet.has(\"compound\") && processor.supportedFeatures.includes(\"compound\")) {\n    const parts = processor.splitCompoundWords(fieldValue);\n    parts.forEach((part) => {\n      if (part.length >= config.minQueryLength) {\n        addToVariantMapWithField(index.variantToBase, part, baseId, fieldName);\n        addToVariantMapWithField(index.variantToBase, processor.normalize(part), baseId, fieldName);\n      }\n    });\n  }\n\n  // Add synonyms\n  if (featureSet.has(\"synonyms\")) {\n    const synonyms = processor.getSynonyms(normalized);\n    synonyms.forEach((synonym) => {\n      addToVariantMapWithField(index.synonymMap, synonym, baseId, fieldName);\n    });\n\n    // Add custom synonyms\n    if (config.customSynonyms) {\n      const customSynonyms = config.customSynonyms[normalized];\n      if (customSynonyms) {\n        customSynonyms.forEach((synonym) => {\n          addToVariantMapWithField(index.synonymMap, synonym, baseId, fieldName);\n        });\n      }\n    }\n  }\n}\n\n/**\n * Helper function to add mappings to variant maps with field information\n */\nfunction addToVariantMapWithField(map: Map<string, Set<string>>, key: string, value: string, _fieldName: string): void {\n  // For now, we'll use a simple approach: store the value with field metadata\n  // The field information will be tracked separately in the index\n  // _fieldName is prefixed with _ to indicate it's reserved for future use\n  if (!map.has(key)) {\n    map.set(key, new Set());\n  }\n  map.get(key)!.add(value);\n}\n\n/**\n * Helper function to add mappings to variant maps\n */\nfunction addToVariantMap(map: Map<string, Set<string>>, key: string, value: string): void {\n  if (!map.has(key)) {\n    map.set(key, new Set());\n  }\n  map.get(key)!.add(value);\n}\n\n/**\n * Batch search multiple queries at once\n * Deduplicates identical queries and returns results for all\n */\nexport function batchSearch(index: FuzzyIndex, queries: string[], maxResults?: number, options: SearchOptions = {}): Record<string, SuggestionResult[]> {\n  const results: Record<string, SuggestionResult[]> = {};\n  const uniqueQueries = [...new Set(queries)]; // Deduplicate\n\n  for (const query of uniqueQueries) {\n    results[query] = getSuggestions(index, query, maxResults, options);\n  }\n\n  return results;\n}\n\n/**\n * Get fuzzy search suggestions from an index\n * Auto-detects whether to use inverted index or classic hash-based approach\n */\nexport function getSuggestions(index: FuzzyIndex, query: string, maxResults?: number, options: SearchOptions = {}): SuggestionResult[] {\n  const config = index.config;\n  const limit = maxResults || options.maxResults || config.maxResults;\n  const threshold = options.fuzzyThreshold || config.fuzzyThreshold;\n\n  if (!query || query.trim().length < config.minQueryLength) {\n    return [];\n  }\n\n  // STOP WORDS: Filter stop words from query if enabled\n  let processedQuery = query;\n  if (config.enableStopWords && config.stopWords && config.stopWords.length > 0) {\n    processedQuery = filterStopWords(query, config.stopWords);\n  }\n\n  // CACHE: Check cache first (use processed query for cache key)\n  if (index._cache) {\n    const cached = index._cache.get(processedQuery, limit, options);\n    if (cached) {\n      return cached; // Cache hit - return immediately!\n    }\n  }\n\n  // Get active language processors\n  const activeLanguages = options.languages || config.languages;\n  const processors = activeLanguages.map((lang) => index.languageProcessors.get(lang)).filter((p): p is LanguageProcessor => p !== undefined);\n\n  if (processors.length === 0) {\n    return [];\n  }\n\n  // AUTO-DETECTION: Use inverted index if available\n  if (index.invertedIndex && index.documents) {\n    const results = getSuggestionsInverted(index, processedQuery, limit, threshold, processors, options);\n    // Cache the results\n    if (index._cache) {\n      index._cache.set(processedQuery, results, limit, options);\n    }\n    return results;\n  }\n\n  // CLASSIC: Use hash-based approach (existing implementation)\n  const matches = new Map<string, SearchMatch>();\n\n  // Process query with each language processor\n  for (const processor of processors) {\n    const normalizedQuery = processor.normalize(processedQuery.trim());\n\n    // Find matches using different strategies\n    findExactMatches(normalizedQuery, index, matches, processor.language);\n    findPrefixMatches(normalizedQuery, index, matches, processor.language);\n    findPhoneticMatches(normalizedQuery, processor, index, matches);\n    findSynonymMatches(normalizedQuery, index, matches);\n    findNgramMatches(normalizedQuery, index, matches, processor.language, config.ngramSize);\n\n    if (config.features.includes(\"missing-letters\") || config.features.includes(\"extra-letters\") || config.features.includes(\"transpositions\")) {\n      findFuzzyMatches(normalizedQuery, index, matches, processor, config);\n    }\n  }\n\n  // Convert matches to results and rank them\n  const results = Array.from(matches.values())\n    .map((match) => createSuggestionResult(match, processedQuery, threshold, index, options))\n    .filter((result): result is SuggestionResult => result !== null)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, limit);\n\n  // Cache the results\n  if (index._cache) {\n    index._cache.set(processedQuery, results, limit, options);\n  }\n\n  return results;\n}\n\n/**\n * Find exact matches\n */\nfunction findExactMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>, language: string): void {\n  const wordBoundaries = index.config.wordBoundaries || false;\n  \n  // Check for wildcard pattern\n  if (query.includes('*')) {\n    // Wildcard search\n    for (const baseWord of index.base) {\n      if (matchesWildcard(baseWord, query)) {\n        if (!matches.has(baseWord)) {\n          matches.set(baseWord, {\n            word: baseWord,\n            normalized: query,\n            matchType: \"exact\",\n            editDistance: 0,\n            language,\n          });\n        }\n      }\n    }\n    return;\n  }\n  \n  // Check for exact matches in the variant map\n  const exactMatches = index.variantToBase.get(query);\n  if (exactMatches) {\n    exactMatches.forEach((word) => {\n      // With word boundaries, verify the match\n      if (wordBoundaries && !matchesWord(word, query, wordBoundaries)) {\n        return;\n      }\n      \n      // Always add exact matches, even if already found with lower score\n      const existing = matches.get(word);\n      if (!existing || existing.matchType !== \"exact\") {\n        matches.set(word, {\n          word,\n          normalized: query,\n          matchType: \"exact\",\n          editDistance: 0,\n          language,\n        });\n      }\n    });\n  }\n\n  // Also check if the query exactly matches any base word (case-insensitive)\n  const queryLower = query.toLowerCase();\n  for (const baseWord of index.base) {\n    if (baseWord.toLowerCase() === queryLower) {\n      if (!matches.has(baseWord)) {\n        matches.set(baseWord, {\n          word: baseWord,\n          normalized: query,\n          matchType: \"exact\",\n          editDistance: 0,\n          language,\n        });\n      }\n    }\n  }\n}\n\n/**\n * Find prefix matches\n */\nfunction findPrefixMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>, language: string): void {\n  const wordBoundaries = index.config.wordBoundaries || false;\n  \n  for (const [variant, words] of index.variantToBase.entries()) {\n    if (variant.startsWith(query) && variant !== query) {\n      words.forEach((word) => {\n        // With word boundaries, verify the match\n        if (wordBoundaries && !matchesWord(word, query, wordBoundaries)) {\n          return;\n        }\n        \n        if (!matches.has(word)) {\n          matches.set(word, {\n            word,\n            normalized: variant,\n            matchType: \"prefix\",\n            language,\n          });\n        }\n      });\n    }\n  }\n}\n\n/**\n * Find phonetic matches\n */\nfunction findPhoneticMatches(query: string, processor: LanguageProcessor, index: FuzzyIndex, matches: Map<string, SearchMatch>): void {\n  if (!processor.supportedFeatures.includes(\"phonetic\")) return;\n\n  const phoneticCode = processor.getPhoneticCode(query);\n  if (phoneticCode) {\n    const phoneticMatches = index.phoneticToBase.get(phoneticCode);\n    if (phoneticMatches) {\n      phoneticMatches.forEach((word) => {\n        if (!matches.has(word)) {\n          matches.set(word, {\n            word,\n            normalized: query,\n            matchType: \"phonetic\",\n            phoneticCode,\n            language: processor.language,\n          });\n        }\n      });\n    }\n  }\n}\n\n/**\n * Find synonym matches\n */\nfunction findSynonymMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>): void {\n  const synonymMatches = index.synonymMap.get(query);\n  if (synonymMatches) {\n    synonymMatches.forEach((word) => {\n      if (!matches.has(word)) {\n        matches.set(word, {\n          word,\n          normalized: query,\n          matchType: \"synonym\",\n          language: \"synonym\",\n        });\n      }\n    });\n  }\n}\n\n/**\n * Find n-gram matches\n */\nfunction findNgramMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>, language: string, ngramSize: number): void {\n  if (query.length < ngramSize) return;\n\n  const queryNgrams = generateNgrams(query, ngramSize);\n  const candidateWords = new Set<string>();\n\n  queryNgrams.forEach((ngram) => {\n    const ngramMatches = index.ngramIndex.get(ngram);\n    if (ngramMatches) {\n      ngramMatches.forEach((word) => candidateWords.add(word));\n    }\n  });\n\n  candidateWords.forEach((word) => {\n    if (!matches.has(word)) {\n      matches.set(word, {\n        word,\n        normalized: query,\n        matchType: \"ngram\",\n        language,\n      });\n    }\n  });\n}\n\n/**\n * Find fuzzy matches using edit distance\n */\nfunction findFuzzyMatches(query: string, index: FuzzyIndex, matches: Map<string, SearchMatch>, processor: LanguageProcessor, config: FuzzyConfig): void {\n  const maxDistance = config.maxEditDistance;\n\n  for (const [variant, words] of index.variantToBase.entries()) {\n    if (Math.abs(variant.length - query.length) <= maxDistance) {\n      const distance = calculateLevenshteinDistance(query, variant, maxDistance);\n\n      if (distance <= maxDistance) {\n        words.forEach((word) => {\n          const existingMatch = matches.get(word);\n          // Don't replace exact or prefix matches with fuzzy matches\n          if (!existingMatch || (existingMatch.matchType !== \"exact\" && existingMatch.matchType !== \"prefix\" && (existingMatch.editDistance || Infinity) > distance)) {\n            matches.set(word, {\n              word,\n              normalized: variant,\n              matchType: \"fuzzy\",\n              editDistance: distance,\n              language: processor.language,\n            });\n          }\n        });\n      }\n    }\n  }\n}\n\n/**\n * Create a suggestion result from a search match\n */\nfunction createSuggestionResult(match: SearchMatch, originalQuery: string, threshold: number, index: FuzzyIndex, options?: SearchOptions): SuggestionResult | null {\n  let score = calculateMatchScore(match, originalQuery);\n\n  // Apply field weight if present\n  if (match.fieldWeight) {\n    score = Math.min(1.0, score * match.fieldWeight);\n  }\n\n  if (score < threshold) {\n    return null;\n  }\n\n  const result: SuggestionResult = {\n    display: match.word,\n    baseWord: match.word,\n    isSynonym: match.matchType === \"synonym\",\n    score,\n    language: match.language,\n    // @ts-ignore - temporary debug property\n    _debug_matchType: match.matchType,\n  };\n\n  // Add field information if this is a multi-field search\n  if (index.fieldData && index.fieldData.has(match.word)) {\n    result.fields = index.fieldData.get(match.word);\n    result.field = match.field;\n  }\n\n  // Add highlights if requested\n  if (options?.includeHighlights) {\n    result.highlights = calculateHighlights(match, originalQuery, match.word);\n  }\n\n  return result;\n}\n\n/**\n * Calculate match score (0-1, higher is better)\n */\nfunction calculateMatchScore(\n  //\n  match: SearchMatch,\n  query: string\n): number {\n  const queryLen = query.length;\n  const wordLen = match.word.length;\n  const maxLen = Math.max(queryLen, wordLen);\n\n  let score = 0.5; // Base score\n\n  switch (match.matchType) {\n    case \"exact\":\n      score = 1.0;\n      break;\n    case \"prefix\":\n      score = 0.9 - (wordLen - queryLen) / (maxLen * 2);\n      break;\n    case \"substring\":\n      score = 0.8;\n      break;\n    case \"phonetic\":\n      score = 0.7;\n      break;\n    case \"fuzzy\":\n      if (match.editDistance !== undefined) {\n        score = Math.max(0.3, 1.0 - match.editDistance / maxLen);\n      }\n      break;\n    case \"synonym\":\n      score = 0.6;\n      break;\n    case \"compound\":\n      score = 0.75;\n      break;\n    case \"ngram\":\n      score = calculateNgramSimilarity(query.toLowerCase(), match.normalized, 3) * 0.8;\n      break;\n  }\n\n  // Boost score for shorter words (more likely to be what user wants)\n  // But don't boost exact matches - they should stay at 1.0\n  if (wordLen <= queryLen + 2 && match.matchType !== \"exact\") {\n    score += 0.1;\n  }\n\n  return Math.min(1.0, Math.max(0.0, score));\n}\n\n/**\n * Generate n-grams from a string\n */\nfunction generateNgrams(\n  //\n  str: string,\n  n: number\n): string[] {\n  if (str.length < n) return [str];\n\n  const ngrams: string[] = [];\n  for (let i = 0; i <= str.length - n; i++) {\n    ngrams.push(str.slice(i, i + n));\n  }\n  return ngrams;\n}\n\n/**\n * Get suggestions using inverted index (for large datasets)\n * This is a wrapper that converts inverted index results to the same format\n */\nfunction getSuggestionsInverted(\n  //\n  index: FuzzyIndex,\n  query: string,\n  limit: number,\n  threshold: number,\n  processors: LanguageProcessor[],\n  options?: SearchOptions\n): SuggestionResult[] {\n  if (!index.invertedIndex || !index.documents) {\n    throw new Error(\"Inverted index not available\");\n  }\n\n  // Use inverted index search\n  const matches = searchInvertedIndex(index.invertedIndex, index.documents, query, processors, index.config);\n\n  // Convert to suggestion results (same as classic approach)\n  const results = matches\n    .map((match) => createSuggestionResult(match, query, threshold, index, options))\n    .filter((result): result is SuggestionResult => result !== null)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, limit);\n\n  return results;\n}\n","/**\n * Index Serialization\n * Save and load fuzzy search indices for 100x faster startup\n */\n\nimport type { FuzzyIndex } from \"./types.js\";\nimport { SearchCache } from \"./cache.js\";\n\n/**\n * Serializable index format (JSON-compatible)\n */\ninterface SerializedIndex {\n  version: string;\n  base: string[];\n  variantToBase: [string, string[]][];\n  phoneticToBase: [string, string[]][];\n  ngramIndex: [string, string[]][];\n  synonymMap: [string, string[]][];\n  config: any;\n  languageProcessorNames: string[];\n  invertedIndex?: any;\n  documents?: any[];\n}\n\n/**\n * Serialize a FuzzyIndex to JSON string\n */\nexport function serializeIndex(index: FuzzyIndex): string {\n  const serialized: SerializedIndex = {\n    version: \"1.0\",\n    base: index.base,\n    variantToBase: Array.from(index.variantToBase.entries()).map(([k, v]) => [k, Array.from(v)]),\n    phoneticToBase: Array.from(index.phoneticToBase.entries()).map(([k, v]) => [k, Array.from(v)]),\n    ngramIndex: Array.from(index.ngramIndex.entries()).map(([k, v]) => [k, Array.from(v)]),\n    synonymMap: Array.from(index.synonymMap.entries()).map(([k, v]) => [k, Array.from(v)]),\n    config: index.config,\n    languageProcessorNames: Array.from(index.languageProcessors.keys()),\n  };\n\n  // Serialize inverted index if present\n  if (index.invertedIndex) {\n    serialized.invertedIndex = {\n      termToPostings: Array.from(index.invertedIndex.termToPostings.entries()),\n      phoneticToPostings: Array.from(index.invertedIndex.phoneticToPostings.entries()),\n      ngramToPostings: Array.from(index.invertedIndex.ngramToPostings.entries()),\n      synonymToPostings: Array.from(index.invertedIndex.synonymToPostings.entries()),\n      totalDocs: index.invertedIndex.totalDocs,\n      avgDocLength: index.invertedIndex.avgDocLength,\n    };\n  }\n\n  // Serialize documents if present\n  if (index.documents) {\n    serialized.documents = index.documents;\n  }\n\n  return JSON.stringify(serialized);\n}\n\n/**\n * Deserialize a FuzzyIndex from JSON string\n */\nexport async function deserializeIndex(json: string): Promise<FuzzyIndex> {\n  const data: SerializedIndex = JSON.parse(json);\n\n  // Reconstruct Maps from arrays\n  const variantToBase = new Map(data.variantToBase.map(([k, v]) => [k, new Set(v)]));\n  const phoneticToBase = new Map(data.phoneticToBase.map(([k, v]) => [k, new Set(v)]));\n  const ngramIndex = new Map(data.ngramIndex.map(([k, v]) => [k, new Set(v)]));\n  const synonymMap = new Map(data.synonymMap.map(([k, v]) => [k, new Set(v)]));\n\n  // Reconstruct language processors (need to import them)\n  const { LanguageRegistry } = await import(\"../languages/index.js\");\n  const languageProcessors = new Map();\n  for (const langName of data.languageProcessorNames) {\n    const processor = LanguageRegistry.getProcessor(langName);\n    if (processor) {\n      languageProcessors.set(langName, processor);\n    }\n  }\n\n  const index: FuzzyIndex = {\n    base: data.base,\n    variantToBase,\n    phoneticToBase,\n    ngramIndex,\n    synonymMap,\n    languageProcessors,\n    config: data.config,\n  };\n\n  // Reconstruct inverted index if present\n  if (data.invertedIndex) {\n    index.invertedIndex = {\n      termToPostings: new Map(data.invertedIndex.termToPostings),\n      phoneticToPostings: new Map(data.invertedIndex.phoneticToPostings),\n      ngramToPostings: new Map(data.invertedIndex.ngramToPostings),\n      synonymToPostings: new Map(data.invertedIndex.synonymToPostings),\n      totalDocs: data.invertedIndex.totalDocs,\n      avgDocLength: data.invertedIndex.avgDocLength,\n    };\n  }\n\n  // Reconstruct documents if present\n  if (data.documents) {\n    index.documents = data.documents;\n  }\n\n  // Reconstruct cache if enabled in config\n  if (data.config.enableCache !== false) {\n    const cacheSize = data.config.cacheSize || 100;\n    index._cache = new SearchCache(cacheSize);\n  }\n\n  return index;\n}\n\n/**\n * Save index to localStorage (browser)\n */\nexport function saveIndexToLocalStorage(index: FuzzyIndex, key: string = \"fuzzy-search-index\"): void {\n  if (typeof localStorage === \"undefined\") {\n    throw new Error(\"localStorage is not available\");\n  }\n  const serialized = serializeIndex(index);\n  localStorage.setItem(key, serialized);\n}\n\n/**\n * Load index from localStorage (browser)\n */\nexport async function loadIndexFromLocalStorage(key: string = \"fuzzy-search-index\"): Promise<FuzzyIndex | null> {\n  if (typeof localStorage === \"undefined\") {\n    throw new Error(\"localStorage is not available\");\n  }\n  const serialized = localStorage.getItem(key);\n  if (!serialized) {\n    return null;\n  }\n  return await deserializeIndex(serialized);\n}\n\n/**\n * Get serialized index size in bytes\n */\nexport function getSerializedSize(index: FuzzyIndex): number {\n  const serialized = serializeIndex(index);\n  return new Blob([serialized]).size;\n}\n","/**\n * FuzzyFindJS - A powerful, multi-language optimized fuzzy search library\n *\n * @example\n * ```typescript\n * import { buildFuzzyIndex, getSuggestions } from 'fuzzyfindjs';\n *\n * const dictionary = ['Krankenhaus', 'Schule', 'Kindergarten'];\n * const index = buildFuzzyIndex(dictionary);\n * const results = getSuggestions(index, 'krankenh', 5);\n * ```\n */\n\n// Core functionality\nexport { buildFuzzyIndex, getSuggestions, batchSearch } from \"./core/index.js\";\nimport { buildFuzzyIndex, getSuggestions } from \"./core/index.js\";\n\n// Highlighting utilities (for UI rendering)\nexport { calculateHighlights, formatHighlightedHTML } from \"./core/highlighting.js\";\n\n// Cache utilities (for advanced users)\nexport { SearchCache, LRUCache } from \"./core/cache.js\";\n\n// Serialization utilities (save/load indices)\nexport { serializeIndex, deserializeIndex, saveIndexToLocalStorage, loadIndexFromLocalStorage, getSerializedSize } from \"./core/serialization.js\";\n\n// Accent normalization utilities\nexport { removeAccents, hasAccents, normalizeForComparison, getAccentVariants } from \"./utils/accent-normalization.js\";\n\n// Stop words utilities\nexport { filterStopWords, getStopWordsForLanguages, isStopWord, DEFAULT_STOP_WORDS } from \"./utils/stop-words.js\";\n\n// Word boundary utilities\nexport { isWordBoundary, matchesAtWordBoundary, findWordBoundaryMatches, matchesWord, matchesWildcard } from \"./utils/word-boundaries.js\";\n\n// Configuration\nexport { DEFAULT_CONFIG, PERFORMANCE_CONFIGS, mergeConfig } from \"./core/config.js\";\n\n// Types\nexport type { FuzzyIndex, FuzzyConfig, SuggestionResult, SearchMatch, MatchType, FuzzyFeature, LanguageProcessor, BuildIndexOptions, SearchOptions, DebugInfo, SuggestionResultWithDebug } from \"./core/types.js\";\n\n// Language processors\nexport { LanguageRegistry, GermanProcessor, EnglishProcessor, SpanishProcessor, FrenchProcessor, BaseLanguageProcessor } from \"./languages/index.js\";\n\n// Algorithms (for advanced users)\nexport { calculateLevenshteinDistance, calculateDamerauLevenshteinDistance, calculateNgramSimilarity, distanceToSimilarity, areStringsSimilar } from \"./algorithms/levenshtein.js\";\n\n/**\n * Quick start function with sensible defaults\n * Perfect for getting started quickly\n */\nexport function createFuzzySearch(\n  dictionary: string[],\n  options: {\n    languages?: string[];\n    performance?: \"fast\" | \"balanced\" | \"comprehensive\";\n    maxResults?: number;\n  } = {}\n) {\n  const index = buildFuzzyIndex(dictionary, {\n    config: {\n      languages: options.languages || [\"german\"],\n      performance: options.performance || \"balanced\",\n      maxResults: options.maxResults || 5,\n    },\n  });\n\n  return {\n    search: (query: string, maxResults?: number) => getSuggestions(index, query, maxResults),\n    index,\n  };\n}\n\n/**\n * Version information\n */\nexport const VERSION = \"1.0.2\";\n"],"names":["DEFAULT_CONFIG","PERFORMANCE_CONFIGS","LANGUAGE_FEATURES","mergeConfig","userConfig","baseConfig","performanceConfig","mergedConfig","recommendedFeatures","lang","feature","validateConfig","config","BaseLanguageProcessor","text","word","normalized","code","consonantMap","i","char","digit","variants","commonEndings","ending","_word","char1","char2","neighbors","n","ngrams","str1","str2","matrix","len1","len2","j","cost","GermanProcessor","prev","next","parts","commonPrefixes","commonSuffixes","commonWords","prefix","remainder","suffix","leftPart","rightPart","part","germanEndings","synonymMap","EnglishProcessor","metaphone","current","length","englishEndings","base","SpanishProcessor","FrenchProcessor","next2","LanguageRegistry","language","languages","processor","calculateLevenshteinDistance","maxDistance","previousRow","currentRow","minInRow","calculateDamerauLevenshteinDistance","maxLen","H","INF","charMap","lastMatchCol","lastMatchRow","result","calculateNgramSimilarity","ngrams1","generateNgrams","ngrams2","set1","set2","intersection","x","union","str","distanceToSimilarity","distance","maxLength","areStringsSimilar","threshold","buildInvertedIndex","words","languageProcessors","featureSet","documents","invertedIndex","totalLength","docId","trimmedWord","phoneticCode","compoundParts","doc","addToPostingList","variant","ngram","normalizedPart","synonym","customSynonyms","searchInvertedIndex","query","processors","matches","normalizedQuery","findExactMatchesInverted","findPrefixMatchesInverted","findPhoneticMatchesInverted","findSynonymMatchesInverted","findNgramMatchesInverted","findFuzzyMatchesInverted","postings","term","posting","ngramSize","queryNgrams","candidateDocs","existingMatch","calculateHighlights","match","displayText","highlights","normalizedDisplay","prefixEnd","substringIndex","calculateFuzzyHighlights","calculateNgramHighlights","mergeOverlappingHighlights","type","queryIdx","textIdx","start","end","searchStart","index","sorted","a","b","merged","last","getMatchTypePriority","formatHighlightedHTML","className","escapeHTML","lastEnd","highlight","highlightedText","div","LRUCache","capacity","key","value","firstKey","SearchCache","maxResults","options","optionsKey","results","cacheStats","total","hitRate","ACCENT_MAP","removeAccents","hasAccents","normalizeForComparison","getAccentVariants","extractFieldValues","item","fields","fieldValues","field","normalizeFieldWeights","fieldWeights","DEFAULT_STOP_WORDS","filterStopWords","stopWords","stopWordsSet","w","filtered","getStopWordsForLanguages","langStopWords","isStopWord","isWordBoundary","position","charBefore","matchesAtWordBoundary","matchStart","matchLength","matchEnd","startBoundary","endBoundary","findWordBoundaryMatches","pattern","caseSensitive","positions","searchText","searchPattern","found","matchesWord","wordBoundaries","parseWildcard","regexPattern","matchesWildcard","buildFuzzyIndex","hasFields","isObjectArray","processedWords","processed","baseId","fieldName","fieldValue","trimmedValue","processWordWithProcessorAndField","processWordWithProcessor","cacheSize","addToVariantMap","accentFreeWord","normalizedAccentFree","addToVariantMapWithField","map","_fieldName","batchSearch","queries","uniqueQueries","getSuggestions","limit","processedQuery","cached","p","getSuggestionsInverted","findExactMatches","findPrefixMatches","findPhoneticMatches","findSynonymMatches","findNgramMatches","findFuzzyMatches","createSuggestionResult","baseWord","exactMatches","existing","queryLower","phoneticMatches","synonymMatches","candidateWords","ngramMatches","originalQuery","score","calculateMatchScore","queryLen","wordLen","serializeIndex","serialized","k","v","deserializeIndex","json","data","variantToBase","phoneticToBase","ngramIndex","langName","saveIndexToLocalStorage","loadIndexFromLocalStorage","getSerializedSize","createFuzzySearch","dictionary","VERSION"],"mappings":"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,YACA,SACA,QAAA,EAEF,OAAQ,CAEN,OACA,WACA,QAAA,EAEF,KAAM,CAEJ,YACA,WAAA,EAEF,IAAK,CAEH,YACA,UACA,YAAA,EAEF,QAAS,CAEP,WACA,UACA,UAAA,EAEF,QAAS,CAEP,SACA,UACA,MAAA,EAEF,OAAQ,CAEN,aACA,WACA,cAAA,CACF,EAGIpC,EAAa,KAAK,UAAUD,CAAI,EACtC,OAAOqC,EAAWpC,CAAU,GAAK,CAAA,CACnC,CAKU,sBAAiD,CACzD,MAAO,CACL,EAAG,CAED,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IACA,GAAA,EAEF,EAAG,CAED,IACA,IA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"}