{"version":3,"file":"bloom-filter.cjs","sources":["../../../src/algorithms/bloom-filter.ts"],"sourcesContent":["/**\n * Bloom Filter Implementation\n * Probabilistic data structure for fast membership testing\n * \n * Benefits:\n * - O(1) lookup time\n * - Space-efficient (much smaller than Set/Map)\n * - No false negatives (if it says \"no\", it's definitely not there)\n * - Small false positive rate (configurable)\n * \n * Use case: Quickly check if a term exists before expensive lookups\n * Saves 50-70% of lookup time for non-existent terms\n */\n\nexport interface BloomFilterConfig {\n  /** Expected number of elements */\n  expectedElements: number;\n  /** Desired false positive rate (0-1, e.g., 0.01 = 1%) */\n  falsePositiveRate: number;\n}\n\nexport class BloomFilter {\n  private bitArray: Uint8Array;\n  private size: number;\n  private numHashFunctions: number;\n  private numElements: number = 0;\n\n  constructor(config: BloomFilterConfig) {\n    // Calculate optimal bit array size\n    // m = -(n * ln(p)) / (ln(2)^2)\n    // where n = expected elements, p = false positive rate\n    const n = config.expectedElements;\n    const p = config.falsePositiveRate;\n    \n    this.size = Math.ceil(-(n * Math.log(p)) / (Math.log(2) ** 2));\n    \n    // Calculate optimal number of hash functions\n    // k = (m / n) * ln(2)\n    this.numHashFunctions = Math.ceil((this.size / n) * Math.log(2));\n    \n    // Use Uint8Array for efficient bit storage (8 bits per byte)\n    this.bitArray = new Uint8Array(Math.ceil(this.size / 8));\n  }\n\n  /**\n   * Add an element to the bloom filter\n   */\n  add(item: string): void {\n    const hashes = this.getHashes(item);\n    \n    for (const hash of hashes) {\n      const byteIndex = Math.floor(hash / 8);\n      const bitIndex = hash % 8;\n      this.bitArray[byteIndex] |= (1 << bitIndex);\n    }\n    \n    this.numElements++;\n  }\n\n  /**\n   * Check if an element might be in the set\n   * Returns:\n   * - true: element MIGHT be in the set (could be false positive)\n   * - false: element is DEFINITELY NOT in the set (no false negatives)\n   */\n  mightContain(item: string): boolean {\n    const hashes = this.getHashes(item);\n    \n    for (const hash of hashes) {\n      const byteIndex = Math.floor(hash / 8);\n      const bitIndex = hash % 8;\n      \n      if ((this.bitArray[byteIndex] & (1 << bitIndex)) === 0) {\n        return false; // Definitely not in set\n      }\n    }\n    \n    return true; // Might be in set\n  }\n\n  /**\n   * Generate multiple hash values for an item\n   * Uses double hashing technique for efficiency\n   */\n  private getHashes(item: string): number[] {\n    const hash1 = this.hash(item, 0);\n    const hash2 = this.hash(item, 1);\n    \n    const hashes: number[] = [];\n    \n    for (let i = 0; i < this.numHashFunctions; i++) {\n      // Double hashing: h(i) = (hash1 + i * hash2) mod m\n      const combinedHash = (hash1 + i * hash2) % this.size;\n      hashes.push(Math.abs(combinedHash));\n    }\n    \n    return hashes;\n  }\n\n  /**\n   * Simple hash function (FNV-1a variant)\n   */\n  private hash(str: string, seed: number): number {\n    let hash = 2166136261 ^ seed; // FNV offset basis\n    \n    for (let i = 0; i < str.length; i++) {\n      hash ^= str.charCodeAt(i);\n      hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n    }\n    \n    return hash >>> 0; // Convert to unsigned 32-bit integer\n  }\n\n  /**\n   * Get current false positive probability\n   * Actual rate may differ from configured rate as elements are added\n   */\n  getFalsePositiveRate(): number {\n    if (this.numElements === 0) return 0;\n    \n    // p = (1 - e^(-kn/m))^k\n    // where k = num hash functions, n = num elements, m = bit array size\n    const k = this.numHashFunctions;\n    const n = this.numElements;\n    const m = this.size;\n    \n    return Math.pow(1 - Math.exp((-k * n) / m), k);\n  }\n\n  /**\n   * Get statistics about the bloom filter\n   */\n  getStats(): {\n    size: number;\n    numHashFunctions: number;\n    numElements: number;\n    falsePositiveRate: number;\n    memoryUsage: number;\n  } {\n    return {\n      size: this.size,\n      numHashFunctions: this.numHashFunctions,\n      numElements: this.numElements,\n      falsePositiveRate: this.getFalsePositiveRate(),\n      memoryUsage: this.bitArray.byteLength,\n    };\n  }\n\n  /**\n   * Clear all elements from the filter\n   */\n  clear(): void {\n    this.bitArray.fill(0);\n    this.numElements = 0;\n  }\n\n  /**\n   * Serialize bloom filter to JSON\n   */\n  toJSON(): {\n    bitArray: number[];\n    size: number;\n    numHashFunctions: number;\n    numElements: number;\n  } {\n    return {\n      bitArray: Array.from(this.bitArray),\n      size: this.size,\n      numHashFunctions: this.numHashFunctions,\n      numElements: this.numElements,\n    };\n  }\n\n  /**\n   * Deserialize bloom filter from JSON\n   */\n  static fromJSON(data: {\n    bitArray: number[];\n    size: number;\n    numHashFunctions: number;\n    numElements: number;\n  }): BloomFilter {\n    // Create a dummy filter with minimal config\n    const filter = new BloomFilter({\n      expectedElements: 100,\n      falsePositiveRate: 0.01,\n    });\n    \n    // Override with saved data\n    filter.bitArray = new Uint8Array(data.bitArray);\n    filter.size = data.size;\n    filter.numHashFunctions = data.numHashFunctions;\n    filter.numElements = data.numElements;\n    \n    return filter;\n  }\n}\n\n/**\n * Create a bloom filter with sensible defaults\n */\nexport function createBloomFilter(expectedElements: number, falsePositiveRate: number = 0.01): BloomFilter {\n  return new BloomFilter({\n    expectedElements,\n    falsePositiveRate,\n  });\n}\n"],"names":[],"mappings":"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"}